// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return S_Curve;

  })();

}).call(this);
