// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
      this._cumulative_lengths = [];
      this._unit_tangents = [];
      this._total_length = 0;
    }

    S_Curve.prototype.addPoint = function(p) {
      this._spline.addPoint(this.vec_to_point(p));
      this._total_length += this._spline.getLastSegmentDistance();
      this._cumulative_lengths.push(this._total_length);
      if (this.numPoints() > 1) {
        this._unit_tangents.push(this._spline.getLastSegmentDirection());
      }
    };

    S_Curve.prototype.numPoints = function() {
      return this._spline.size();
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this.point_to_vec(this._spline.getPoint(i));
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.point_to_vec(this._spline.getLastPoint());
    };

    S_Curve.prototype.removeLastPoint = function() {
      this._total_length -= this._spline.getLastSegmentDistance();
      this._cumulative_lengths.pop();
      this._unit_tangents.pop();
      return this._spline.removeLastPoint();
    };

    S_Curve.prototype.position = function(t) {
      var dir, distance, distance_to_go, i1, i2, p1, p2, start_distance;
      i1 = this._get_segment_start_index(t);
      if (i1 >= this.numPoints() - 1) {
        return this.getLastPoint();
      }
      i2 = i1 + 1;
      distance = t * this._total_length;
      start_distance = this._cumulative_lengths[i1];
      distance_to_go = distance - start_distance;
      p1 = this._spline.getPoint(i1);
      p2 = this._spline.getPoint(i2);
      dir = p1.directionTo(p2);
      return this.point_to_vec(p1.add(dir.multScalar(distance_to_go)));
    };

    S_Curve.prototype.tangent = function(t) {
      var index;
      index = this._get_segment_start_index(t);
      if (index >= this._unit_tangents.length) {
        index--;
      }
      return this.point_to_vec(this._unit_tangents[index]);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype._get_segment_start_index = function(t) {
      var distance;
      distance = t * this._total_length;
      return BDS.Arrays.binarySearch(this._cumulative_lengths, distance);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var index, j, len, ref, vec;
      this._discretization = [];
      len = this.numPoints();
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        vec = this.getPointAtIndex(index);
        this._discretization.push(vec);
      }
      return this._discretization;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var distance, j, len, len1, out, ref, time;
      out = [];
      len = 0;
      ref = this._cumulative_lengths;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        distance = ref[j];
        time = distance / this._total_length;
        times_output.push(time);
        out.push(this.offset(time, amount));
      }
      return out;
    };


    /*
    updateDiscretization: (max_length) ->
        output = []
        p0 = @position(0)
        output.push(p0)
    
        S = [] # Stack.
        S.push(1.0)
        
        low   = 0
        p_low = @position(low)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval
         * every time an interval is less than the max_length, subdivision is terminated.
    
         * Left to right subdivision loop. Performs a binary search across all intervals.
        while S.length != 0
        
            high   = S.pop()
            p_high = @position(high)
        
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high   = (low + high)/2.0
                p_high = @position(high)
        
            output.push(p_high)
            low   = high
            p_low = p_high
            continue
    
        @_discretization = output
    
     * max_length:float, maximum length out output segment.
     * amount: the distance the offset curve is away from the main curve. positive or negative is fine.
     * time_output (optional) will be populated with the times for the output points.
     * ASSUMPTION: this function assumes that it is sampling from continuously defined offsets.
    getOffsets: (max_length, amount, times_output) ->
    
        o0 = @offset(0, amount)
        output = []
        output.push(o0)
        times_output.push(0) if times_output
    
        S = []; # Stack.
        S.push(1.0)
        low = 0
        p_low = @offset(low, amount)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval.
         * every time an interval is terminated after subdivision is sufficient.
    
         * Left to right subdivision loop.
        while S.length != 0
        
            high   = S.pop()
            p_high = @offset(high, amount)
    
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
            
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high = (low + high)/2.0
                p_high = @offset(high, amount)
            
    
            output.push(p_high)
            times_output.push(high) if times_output
            low = high
            p_low = p_high
            continue
        
        return output
     */

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len1, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len1 = vecs.length; j < len1; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    S_Curve.prototype.vec_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y);
    };

    S_Curve.prototype.point_to_vec = function(pt) {
      return new THREE.Vector3(pt.x, pt.y);
    };

    S_Curve.prototype.length = function() {
      return this._total_length;
    };

    return S_Curve;

  })();

}).call(this);
