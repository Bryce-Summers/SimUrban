// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.legal = false;
      this.next_point = null;
      this.network = this.e_scene.getNetwork();
      this.generator = this.network.getGenerator();
      this.linker = this.network.getLinker();
      this.isects = [];
      this.isects_last_segment = [];
    }

    I_Mouse_Build_Road.prototype.isIdle = function() {
      return this.state === "idle";
    };

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, i, intersection, isect, isect_pt, len, pos, ref, start_element, x, y;
      if (this.state === "idle") {
        this.road = new TSAG.E_Road();
        this.network.addVisual(this.road.getVisual());
        x = event.x;
        y = event.y;
        start_element = this._getIsectOrRoadAtPt(x, y);
        if (start_element instanceof TSAG.E_Intersection) {
          isect_pt = start_element.getPoint();
          x = isect_pt.x;
          y = isect_pt.y;
          this.isects.push({
            isect: start_element,
            type: 'p'
          });
        } else if (start_element instanceof TSAG.E_Road) {
          intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
          this.network.addVisual(intersection.getVisual());
          this.isects.push({
            isect: intersection,
            type: 's',
            road: start_element
          });
        } else {
          intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
          this.network.addVisual(intersection.getVisual());
          this.isects.push({
            isect: intersection,
            type: 'i'
          });
        }
        this.road.addPoint(new THREE.Vector3(x, y, 0));
        this.next_point = new THREE.Vector3(x, y + 1, 0);
        this.road.addPoint(this.next_point);
        this.state = "building";
        this._mousePrevious.x = event.x;
        return this._mousePrevious.y = event.y;
      } else if (this.state === "building") {
        if (!this.legal) {
          return;
        }
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          this.road.updateLastPoint(pos);
          this.next_point = new THREE.Vector3(event.x + .01, event.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          this._mousePrevious.y = event.y;
          ref = this.isects_last_segment;
          for (i = 0, len = ref.length; i < len; i++) {
            isect = ref[i];
            this.isects.push(isect);
          }
          return this.isects_last_segment = [];
        } else {
          return this.finish();
        }
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var max_length;
      if (this.state === "building") {
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        this.road.updateLastPoint(this.next_point);
        max_length = TSAG.style.discretization_length;
        this.road.updateDiscretization(max_length);
        return this.updateTemporaryRoad();
      }
    };

    I_Mouse_Build_Road.prototype.finish = function() {
      var end_element, end_pt, i, intersection, isect, isect_obj, isect_pt, j, len, len1, max_length, ref, ref1, x, y;
      if (this.state !== "building") {
        return;
      }
      this.road.removeLastPoint();
      this.state = "idle";
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      end_pt = this.road.getLastPoint();
      x = end_pt.x;
      y = end_pt.y;
      end_element = this._getIsectOrRoadAtPt(end_pt.x, end_pt.y);
      if (end_element instanceof TSAG.E_Intersection) {
        isect_pt = end_element.getPoint();
        x = isect_pt.x;
        y = isect_pt.y;
        this.isects.push({
          isect: end_element,
          type: 'p'
        });
      } else if (end_element instanceof TSAG.E_Road) {
        intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
        this.isects.push({
          isect: intersection,
          type: 's',
          road: end_element
        });
      } else {
        intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
        this.isects.push({
          isect: intersection,
          type: 'i'
        });
      }
      this.network.removeVisual(this.road.getVisual());
      ref = this.isects;
      for (i = 0, len = ref.length; i < len; i++) {
        isect_obj = ref[i];
        if (isect_obj.type !== 'p') {
          this.network.removeVisual(isect_obj.isect.getVisual());
        }
      }
      this.network.addCollisionPolygons(this.road.to_collision_polygons());
      ref1 = this.isects;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        isect_obj = ref1[j];
        isect = isect_obj.isect;
        this.network.addCollisionPolygon(isect.getCollisionPolygon());
      }
      this.network.addRoad(this.road);
      this.road = null;
      this.isects = [];
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.updateTemporaryRoad = function() {
      this.destroyLastSegmentIsects();
      if (!this.checkLegality()) {
        this.road.setFillColor(TSAG.style.error);
        this.legal = false;
        return;
      }
      this.road.revertFillColor();
      this.legal = true;
      return this.createTempIntersections();
    };

    I_Mouse_Build_Road.prototype.destroyLastSegmentIsects = function() {
      var collision_polygon, i, isect, isect_obj, len, ref;
      ref = this.isects_last_segment;
      for (i = 0, len = ref.length; i < len; i++) {
        isect_obj = ref[i];
        if (isect_obj.type === 'p') {
          continue;
        }
        isect = isect_obj.isect;
        this.network.removeVisual(isect.getVisual());
        collision_polygon = isect.getCollisionPolygon();
        this.network.removeCollisionPolygon(collision_polygon);
      }
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.checkLegality = function() {
      var collision_polygon, query_box;
      collision_polygon = this.road.generateCollisionPolygon();
      return query_box = collision_polygon.generateBoundingBox();
    };

    I_Mouse_Build_Road.prototype.createTempIntersections = function() {
      var e_polyline, e_road, elem, elements, i, last_direction, last_point, len, p1, p2, polyline, query_box, query_polyline, temp_polyline, width;
      polyline = this.road.getCenterPolyline();
      temp_polyline = polyline.getLastSegment();
      query_box = temp_polyline.generateBoundingBox();
      elements = this.network.query_elements_box(query_box);
      for (i = 0, len = elements.length; i < len; i++) {
        elem = elements[i];
        if (elem instanceof TSAG.E_Road) {
          e_polyline = elem.getCenterPolyline();
          this._intersectPolygons(temp_polyline, e_polyline);
        }
      }
      last_point = temp_polyline.getLastPoint();
      last_direction = temp_polyline.getLastDirection();
      e_road = this._getRoadAtPt(last_point.x, last_point.y);
      if (e_road !== null) {
        e_polyline = e_road.getCenterPolyline();
        width = e_road.getWidth();
        p1 = last_point;
        p2 = last_point.add(last_direction.multScalar(width));
        query_polyline = new BDS.Polyline(false, [p1, p2]);
        this._intersectPolygons(query_polyline, e_polyline, e_road);
      }
    };

    I_Mouse_Build_Road.prototype._intersectPolygons = function(poly1, poly2, road_in_embedding) {
      var i, intersection, isect_pts, len, pt, results;
      isect_pts = poly1.report_intersections_with_polyline(poly2);
      results = [];
      for (i = 0, len = isect_pts.length; i < len; i++) {
        pt = isect_pts[i];
        intersection = new TSAG.E_Intersection(pt);
        this.isects_last_segment.push({
          isect: intersection,
          type: 's',
          road: road_in_embedding
        });
        this.network.addVisual(intersection.getVisual());
        results.push(this.network.addCollisionPolygon(intersection.getCollisionPolygon()));
      }
      return results;

      /*
       * Add intersections every time the mouse cursor intersects an older road.
      road_model = @network.query_road(event.x, event.y)
      if road_model != null
          @network.newIntersection(road_model.getPosition())
       */
    };

    I_Mouse_Build_Road.prototype._getIsectOrRoadAtPt = function(x, y) {
      var elem, elems, i, j, len, len1;
      elems = this.network.query_elements_pt(x, y);
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Intersection) {
          return elem;
        }
      }
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    I_Mouse_Build_Road.prototype._getRoadAtPt = function(x, y) {
      var elem, elems, i, len;
      elems = this.network.query_elements_pt(x, y);
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);
