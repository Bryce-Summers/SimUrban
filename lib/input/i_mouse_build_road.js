// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.legal = false;
      this.next_point = null;
      this.network = this.e_scene.getNetwork();
      this._generator = this.network.getGenerator();
      this._linker = this.network.getLinker();
      this.isects = [];
      this.isects_last_segment = [];
    }

    I_Mouse_Build_Road.prototype.isIdle = function() {
      return this.state === "idle";
    };

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, isect, isect_obj, j, len1, max_length, pos, pt, ref, temp, x, y;
      if (this.state === "idle") {
        this.road = new TSAG.E_Road();
        this.network.addVisual(this.road.getVisual());
        isect_obj = this.classify_or_construct_intersection(event.x, event.y);
        this.start_or_end_point(isect_obj);
        this.isects.push(isect_obj);
        pt = isect_obj.point;
        x = pt.x;
        y = pt.y;
        this.road.addPoint(new THREE.Vector3(x, y, 0));
        this.next_point = new THREE.Vector3(x, y + 1, 0);
        this.road.addPoint(this.next_point);
        this.road.setRevert();
        max_length = TSAG.style.discretization_length;
        this.road.updateVisual(max_length);
        this.state = "building";
        this._mousePrevious.x = event.x;
        this._mousePrevious.y = event.y;
      } else if (this.state === "building") {
        if (!this.legal) {
          return;
        }
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          isect_obj = this.classify_or_construct_intersection(event.x, event.y);
          pos = isect_obj.point;
          this.road.updateLastPoint(pos);
          this.next_point = new THREE.Vector3(event.x + .01, event.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          this._mousePrevious.y = event.y;
          temp = this.isects.pop();
          if (temp.type !== 'i') {
            this.isects.push(temp);
          }
          ref = this.isects_last_segment;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            isect = ref[j];
            this.isects.push(isect);
          }
          this.isects_last_segment = [];
          this.isects.push(isect_obj);
          this.road.setRevert();
        } else {
          this.finish();
        }
      }
    };

    I_Mouse_Build_Road.prototype.classify_or_construct_intersection = function(x, y) {
      var element, intersection, isect_pt, out, pt;
      pt = new BDS.Point(x, y);
      element = this._getIsectOrRoadAtPt();
      out = null;
      if (element instanceof TSAG.E_Intersection) {
        isect_pt = element.getPoint();
        out = {
          isect: start_element,
          type: 'p',
          point: isect_pt
        };
      } else if (element instanceof TSAG.E_Road) {
        debugger;
        intersection = new TSAG.E_Intersection(pt);
        this.network.addVisual(intersection.getVisual());
        out = {
          isect: intersection,
          type: 's',
          road: start_element,
          point: pt
        };
      } else {
        out = {
          type: 'i',
          point: pt
        };
      }
      return out;
    };

    I_Mouse_Build_Road.prototype.start_or_end_point = function(isect_obj) {
      var intersection, pt;
      if (isect_obj.type === 'i') {
        pt = isect_obj.point;
        intersection = new TSAG.E_Intersection(pt);
        this.network.addVisual(intersection.getVisual());
        isect_obj.isect = intersection;
        return isect_obj.type = 't';
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var max_length;
      if (this.state === "building") {
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        max_length = TSAG.style.discretization_length;
        this.road.updateDiscretization(max_length);
        return this.updateTemporaryRoad();
      }
    };

    I_Mouse_Build_Road.prototype.finish = function() {
      var collision_polygon, end_pt, i, isect, isect_obj, isects, j, k, l, last_isect, len, len1, len2, len3, m, max_length, obj1, obj2, ref, ref1, ref2, ref3, road, road_edge, split_isect, split_vert, type, vert, vert1, vert2, x, y;
      if (this.state !== "building") {
        return;
      }
      this.road.removeLastPoint();
      this.state = "idle";
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      end_pt = this.road.getLastPoint();
      x = end_pt.x;
      y = end_pt.y;
      last_isect = this.isects[this.isects.length - 1];
      this.start_or_end_point(last_isect);
      this.network.removeVisual(this.road.getVisual());
      this.road = null;

      /*
      for isect_obj in @isects
          if isect_obj.type != 'p'
              @network.removeVisual(isect_obj.isect.getVisual())
       */
      ref = this.isects;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        isect_obj = ref[j];
        type = isect_obj.type;
        if (type !== 'p' && type !== 'i') {
          isect = isect_obj.isect;
          collision_polygon = isect.getCollisionPolygon();
          this.network.addCollisionPolygon(collision_polygon);
        }
      }
      ref1 = this.isects;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        isect_obj = ref1[k];
        if (isect_obj.type !== 's') {
          continue;
        }
        road_edge = isect_obj.road_edge;
        road = road_edge.data.element;
        this.network.removeVisual(road.getVisual());
        this.network.removeCollisionPolygon(road.getCollisionPolygon());
        this.network.removeRoad(road);
        split_vert = this._generator.newVertex();
        split_isect = isect_obj.isect;
        split_vert.data.point = split_isect.getPoint();
        isect_obj.type = 'p';
        split_isect.setTopology(split_vert);
        split_vert.data.element = split_isect;
        this._linker.split_edge_with_vert(road_edge, split_vert);
        isects = this._populate_split_path(road, split_vert);
        this.construct_roads_along_isect_path(isects);
      }
      ref2 = this.isects;
      for (l = 0, len3 = ref2.length; l < len3; l++) {
        isect_obj = ref2[l];
        if (isect_obj.type === 'p') {
          isect_obj.vert = isect_obj.isect.getTopology();
          continue;
        }
        vert = this._generator.newVertex();
        if (isect_obj.type !== 'i') {
          isect = isect_obj.isect;
          isect.setTopology(vert);
          vert.data.element = isect;
          vert.data.point = isect.getPoint();
        } else {
          vert.data.point = isect_obj.point;
        }
        isect_obj.vert = vert;
        continue;
      }
      len = this.isects.length;

      /*
      for i = 0; i < len - 1; i++
       */
      for (i = m = 0, ref3 = len - 1; m < ref3; i = m += 1) {
        obj1 = this.isects[i];
        obj2 = this.isects[i + 1];
        vert1 = obj1.vert;
        vert2 = obj2.vert;
        this._linker.link_verts(vert1, vert2);
      }
      this.construct_roads_along_isect_path(this.isects);

      /*
      
       * 2. Use the linker to link this graph.
      
       * 3. Create Roads and associate intersections.
       *    Associate every road with a path.
       *    The roads need to have arc curve, instead of the temporary solution that we have right now.
       *    This can come later.
      
      
       * Add the road's collision polygons to the network BVH.
       * FIXME: Add a bounding polygon instead.
      @network.addCollisionPolygons(@road.to_collision_polygons())
      
       * Make all intersections collidable.
      for isect_obj in @isects
          isect = isect_obj.isect
          @network.addCollisionPolygon(isect.getCollisionPolygon())
      
       * Embed the road topology between the list of intersections.
       * This will enable vehicles to move on the new road,
       * it will also update the areas.
      #@embedRoadTopology()
      
       * FIXME: Make a better way of managing roads.
      @network.addRoad(@road)
      
       * Preserve the road object.
      @road = null
       */
      this.isects = [];
      this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype._populate_split_path = function(road, split_vert) {
      var halfedge, isect_obj, isects, vert1, vert2, vert3;
      vert1 = road.getStartVertex();
      vert2 = split_vert;
      vert3 = road.getEndVertex();
      isects = [];
      halfedge = vert1.get_outgoing_halfedge_to(split_vert);
      if (halfedge === null) {
        halfedge = road.getHalfedge();
      }
      isect_obj = {
        isect: vert1.data.element,
        type: 'p',
        point: vert1.data.point,
        vert: vert1
      };
      isects.push(isect_obj);
      halfedge = this._append_intermediate_isects_until_vert(halfedge.next, vert2, isects);
      isect_obj = {
        isect: vert2.data.element,
        type: 's',
        point: vert2.data.point,
        vert: vert2
      };
      isects.push(isect_obj);
      halfedge = this._append_intermediate_isects_until_vert(halfedge.next, vert3, isects);
      isect_obj = {
        isect: vert3.data.element,
        type: 'p',
        point: vert3.data.point,
        vert: vert3
      };
      isects.push(isect_obj);
      return isects;
    };

    I_Mouse_Build_Road.prototype._append_intermediate_isects_until_vert = function(halfedge, stop_vert, output) {
      var c_isect, c_point, c_vert, isect_obj;
      while (true) {
        c_vert = halfedge.vertex;
        if (c_vert === stop_vert) {
          break;
        }
        c_isect = c_vert.data.element;
        c_point = c_vert.data.point;
        isect_obj = {
          isect: c_isect,
          type: 'i',
          point: c_point,
          vert: c_vert
        };
        output.push(isect_obj);
        halfedge = halfedge.next;
      }
      return halfedge;
    };

    I_Mouse_Build_Road.prototype.construct_roads_along_isect_path = function(isects) {
      var _road, edge, halfedge, i, isect_obj, j, prev_isect_obj, ref, vert, vert_prev;
      _road = new TSAG.E_Road();
      this.network.addVisual(_road.getVisual());
      _road.addPoint(isects[0].point);
      _road.setStartVertex(isects[0].vert);
      for (i = j = 1, ref = isects.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        isect_obj = isects[i];
        prev_isect_obj = isects[i - 1];
        vert_prev = prev_isect_obj.vert;
        vert = isect_obj.vert;
        halfedge = vert_prev.get_outgoing_halfedge_to(vert);
        edge = halfedge.edge;
        edge.data.element = _road;
        _road.addPoint(isect_obj.point);
        if (_road.getHalfedge() === null) {
          _road.setHalfedge(halfedge);
        }
        if (isect_obj.type === 'i') {
          vert.data.element = _road;
          continue;
        }
        _road.setEndVertex(vert);
        _road.updateDiscretization(TSAG.style.discretization_length);
        this.network.addCollisionPolygon(_road.getCollisionPolygon());
        this.network.addRoad(_road);
        _road = null;
        if (isect_obj.type === 't') {
          break;
        }
        _road = new TSAG.E_Road();
        this.network.addVisual(_road.getVisual());
        _road.addPoint(isect_obj.point);
        _road.setStartVertex(vert);
        continue;
      }
    };

    I_Mouse_Build_Road.prototype.updateTemporaryRoad = function() {
      this.destroyLastSegmentIsects();
      this.road.updateLastPoint(this.next_point);
      if (!this.checkLegality()) {
        this.road.setFillColor(TSAG.style.error);
        this.legal = false;
        return;
      }
      this.road.revertFillColor();
      this.legal = true;
      return this.createTempIntersections();
    };

    I_Mouse_Build_Road.prototype.destroyLastSegmentIsects = function() {
      var collision_polygon, isect, isect_obj, j, len1, ref;
      this.road.revert();
      ref = this.isects_last_segment;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        isect_obj = ref[j];
        if (isect_obj.type !== 's') {
          continue;
        }
        isect = isect_obj.isect;
        this.network.removeVisual(isect.getVisual());
        collision_polygon = isect.getCollisionPolygon();
        this.network.removeCollisionPolygon(collision_polygon);
      }
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.checkLegality = function() {
      var collision_polygon, query_box;
      collision_polygon = this.road.generateCollisionPolygon();
      return query_box = collision_polygon.generateBoundingBox();
    };

    I_Mouse_Build_Road.prototype.createTempIntersections = function() {
      var e_polyline, e_road, elem, elements, j, last_direction, last_point, len1, p1, p2, polyline, pt1, pt2, pt3, query_box, query_polyline, temp_polyline, width;
      polyline = this.road.getCenterPolyline();
      temp_polyline = polyline.getLastSegment();
      query_box = temp_polyline.generateBoundingBox();
      elements = this.network.query_elements_box(query_box);
      for (j = 0, len1 = elements.length; j < len1; j++) {
        elem = elements[j];
        if (elem instanceof TSAG.E_Road) {
          e_polyline = elem.getCenterPolyline();
          this._intersectPolygons(e_polyline, temp_polyline, elem);
        }
      }
      last_point = temp_polyline.getLastPoint();
      last_direction = temp_polyline.getLastDirection();
      e_road = this._getRoadAtPt(last_point.x, last_point.y);
      if (e_road !== null) {
        e_polyline = e_road.getCenterPolyline();
        width = e_road.getWidth();
        p1 = last_point;
        p2 = last_point.add(last_direction.multScalar(width));
        query_polyline = new BDS.Polyline(false, [p1, p2]);
        this._intersectPolygons(e_polyline, query_polyline, e_road);
      }
      if (this.road.numPoints() > 2) {
        return;
        pt1 = this.road.getPointAtIndexFromEnd(2);
        pt2 = this.road.getPointAtIndexFromEnd(1);
        pt3 = this.road.getPointAtIndexFromEnd(0);
        this.road.removeLastPoint();
        this.road.removeLastPoint();
        pt1 = this.vec_to_pt(pt1);
        pt2 = this.vec_to_pt(pt2);
        pt3 = this.vec_to_pt(pt3);
        this._createTempCurve(pt1, pt2, pt3);
      }
    };

    I_Mouse_Build_Road.prototype._createTempCurve = function(pt0, pt1, pt2) {
      var b1, b2, d1, d2, d3, isect_obj, j, pt, results, t, time;
      d1 = pt1.sub(pt0);
      d2 = pt2.sub(pt1);
      results = [];
      for (t = j = 1; j <= 10; t = ++j) {
        time = t / 10.0;
        b1 = pt0.add(d1.multScalar(time));
        b2 = pt1.add(d2.multScalar(time));
        d3 = b2.sub(b1);
        pt = b1.add(d3.multScalar(time));
        isect_obj = {
          type: 'i',
          point: pt
        };
        this.isects_last_segment.push(isect_obj);
        results.push(this.road.addPoint(this.pt_to_vec(pt)));
      }
      return results;
    };

    I_Mouse_Build_Road.prototype.vec_to_pt = function(vec) {
      var x, y, z;
      x = vec.x;
      y = vec.y;
      z = vec.z;
      return new BDS.Point(x, y, z);
    };

    I_Mouse_Build_Road.prototype.pt_to_vec = function(pt) {
      var x, y, z;
      x = pt.x;
      y = pt.y;
      z = pt.z;
      return new THREE.Vector3(x, y, z);
    };

    I_Mouse_Build_Road.prototype._intersectPolygons = function(perm_poly, new_poly, road_in_embedding) {
      var data, edge, edge_index, halfedge, i, intersection, isect_datas, j, k, len1, pt, ref;
      isect_datas = perm_poly.report_intersections_with_polyline(new_poly);
      for (j = 0, len1 = isect_datas.length; j < len1; j++) {
        data = isect_datas[j];
        pt = data.point;
        edge_index = data.index;
        halfedge = road_in_embedding.getHalfedge();
        for (i = k = 0, ref = edge_index; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          halfedge = halfedge.next;
        }
        edge = halfedge.edge;
        intersection = new TSAG.E_Intersection(pt);
        this.isects_last_segment.push({
          isect: intersection,
          type: 's',
          road_edge: edge,
          point: intersection.getPoint()
        });
        this.network.addVisual(intersection.getVisual());
        this.network.addCollisionPolygon(intersection.getCollisionPolygon());
      }

      /*
       * Add intersections every time the mouse cursor intersects an older road.
      road_model = @network.query_road(event.x, event.y)
      if road_model != null
          @network.newIntersection(road_model.getPosition())
       */
    };

    I_Mouse_Build_Road.prototype._getIsectOrRoadAtPt = function(x, y) {
      var elem, elems, j, k, len1, len2;
      elems = this.network.query_elements_pt(x, y);
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Intersection) {
          return elem;
        }
      }
      for (k = 0, len2 = elems.length; k < len2; k++) {
        elem = elems[k];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    I_Mouse_Build_Road.prototype._getRoadAtPt = function(x, y) {
      var elem, elems, j, len1;
      elems = this.network.query_elements_pt(x, y);
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);

//# sourceMappingURL=i_mouse_build_road.js.map
