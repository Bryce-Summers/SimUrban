// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.next_point = null;
      this.network = this.e_scene.getNetwork();
      this.intersections_perm = [];
      this.intersections_temp = [];
    }

    I_Mouse_Build_Road.prototype.isIdle = function() {
      return this.state === "idle";
    };

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, intersection, pos;
      if (this.state === "idle") {
        this.road = new TSAG.E_Road();
        this.network.addVisual(this.road.getVisual());
        intersection = new TSAG.E_Intersection(new BDS.Point(event.x, event.y));
        this.network.addVisual(intersection.getVisual());
        this.intersections_perm.push(intersection);
        this.road.addPoint(new THREE.Vector3(event.x, event.y, 0));
        this.next_point = new THREE.Vector3(event.x, event.y + 1, 0);
        this.road.addPoint(this.next_point);
        this.state = "building";
        this._mousePrevious.x = event.x;
        return this._mousePrevious.y = event.y;
      } else {
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          this.next_point = new THREE.Vector3(event.x + .01, event.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          return this._mousePrevious.y = event.y;
        } else {
          return this.finish();
        }
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var max_length;
      if (this.state === "building") {
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        max_length = TSAG.style.discretization_length;
        this.road.updateDiscretization(max_length);
        return this.updateTempIntersections();
      }
    };

    I_Mouse_Build_Road.prototype.finish = function() {
      var i, intersection, isect, len, max_length, ref;
      if (this.state !== "building") {
        return;
      }
      this.road.removeLastPoint();
      this.state = "idle";
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      intersection = new TSAG.E_Intersection(new BDS.Point(this._mousePrevious.x, this._mousePrevious.y));
      this.network.addVisual(intersection.getVisual());
      this.intersections_perm.push(intersection);
      this.network.addCollisionPolygons(this.road.to_collision_polygons());
      ref = this.intersections_perm;
      for (i = 0, len = ref.length; i < len; i++) {
        isect = ref[i];
        this.network.addCollisionPolygon(isect.getCollisionPolygon());
      }
      this.road = null;
      this.intersections_temp = [];
      return this.intersections_perm = [];
    };

    I_Mouse_Build_Road.prototype.updateTempIntersections = function() {
      this.destroyTempIntersections();
      return this.createTempIntersections();
    };

    I_Mouse_Build_Road.prototype.createTempIntersections = function() {
      var collision_polygon, e_polyline, elem, elements, i, isect, isect_pts, j, len, len1, polyline, pt, query_box;
      polyline = this.road.getCenterPolyline();
      collision_polygon = this.road.generateCollisionPolygon();
      query_box = collision_polygon.generateBoundingBox();
      elements = this.network.query_elements_box(query_box);
      for (i = 0, len = elements.length; i < len; i++) {
        elem = elements[i];
        if (elem instanceof TSAG.E_Road) {
          e_polyline = elem.getCenterPolyline();
          isect_pts = polyline.report_intersections_with_polyline(e_polyline);
          for (j = 0, len1 = isect_pts.length; j < len1; j++) {
            pt = isect_pts[j];
            isect = new TSAG.E_Intersection(pt);
            this.intersections_temp.push(isect);
            this.network.addVisual(isect.getVisual());
            this.network.addCollisionPolygon(isect.getCollisionPolygon());
          }
        }
      }

      /*
       * Add intersections every time the mouse cursor intersects an older road.
      road_model = @network.query_road(event.x, event.y)
      if road_model != null
          @network.newIntersection(road_model.getPosition())
       */
    };

    I_Mouse_Build_Road.prototype.destroyTempIntersections = function() {
      var collision_polygon, i, isect, len, ref, results;
      ref = this.intersections_temp;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        isect = ref[i];
        this.network.removeVisual(isect.getVisual());
        collision_polygon = isect.getCollisionPolygon();
        results.push(this.network.removeCollisionPolygon(collision_polygon));
      }
      return results;
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);
