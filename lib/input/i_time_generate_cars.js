// Generated by CoffeeScript 1.11.1

/*

Building Rotation Time Controller.

Written by Bryce Summmers on 1 - 31 - 2017.

 - A Test time controller that takes every building in the scene and rotates it by a steady rate.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Generate_Cars = (function(superClass) {
    extend(I_Time_Generate_Cars, superClass);

    function I_Time_Generate_Cars(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Generate_Cars.__super__.constructor.call(this);
      this.time_count = 0.0;
      this.time_step = 2000.0;
    }

    I_Time_Generate_Cars.prototype.time = function(dt) {
      var car, i, i_vert, incoming_halfedge, intersection, j, k, l, lane, lanes, len, len1, len2, len3, m, n, network, outgoing_halfedge, outputs, ref, road, roads, src_vert, times, x, y;
      this.time_count += dt;
      this.gen_cars = false;
      if (this.time_count > this.time_step) {
        this.time_count = (this.time_count % this.time_step) - this.time_step;
        this.gen_cars = true;
      }
      network = this.scene.getNetwork();
      roads = network.getRoads();
      for (j = 0, len = roads.length; j < len; j++) {
        road = roads[j];
        lanes = road.getLanes();
        for (k = 0, len1 = lanes.length; k < len1; k++) {
          lane = lanes[k];
          if (this.gen_cars && lane.deadStart()) {
            x = TSAG.style.road_offset_amount;
            y = TSAG.style.road_offset_amount;
            car = new TSAG.E_Car(new THREE.Vector3(x, y, 1));
            network.addVisual(car.getVisual());
            lane.addCar(car);
          }
          if (lane.isEmpty()) {
            continue;
          }
          outputs = lane.moveCars();
          if (outputs.length === 0) {
            continue;
          }
          if (lane.deadEnd()) {
            for (l = 0, len2 = outputs.length; l < len2; l++) {
              car = outputs[l];
              network.removeVisual(car.getVisual());
            }
          }
          i_vert = lane.getEndVert();
          src_vert = lane.getStartVert();
          intersection = i_vert.data.element;
          incoming_halfedge = intersection.getIncomingHalfedgeFrom(src_vert);
          times = Math.floor(Math.random() * 2) + 1;
          for (i = m = 0, ref = times; m < ref; i = m += 1) {
            incoming_halfedge = incoming_halfedge.twin.prev;
          }
          outgoing_halfedge = incoming_halfedge.twin;
          road = outgoing_halfedge.edge.data.element;
          for (n = 0, len3 = outputs.length; n < len3; n++) {
            car = outputs[n];
            road.addCar(car, i_vert);
            car.resetLaneInfo();
          }
        }
      }
    };

    return I_Time_Generate_Cars;

  })(BDS.Interface_Controller_Time);

}).call(this);

//# sourceMappingURL=i_time_generate_cars.js.map
