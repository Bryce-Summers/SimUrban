// Generated by CoffeeScript 1.11.1

/*

Written on Oct.07.2017 by Bryce Summers
Purpose: Creates THREE.js paths.
 */

(function() {
  EX.Path_Visual_Factory = (function() {
    function Path_Visual_Factory(polyline, width, color, show_outline) {
      this.vecs = this._BDS_Polyline_to_THREE_vertex_list(polyline);
      this.width = width;
      this.color = color;
      this.spline = new THREE.CatmullRomCurve3(this.vecs);
      this.curve = new BDS.Curve(this.spline);
      this.show_outline = show_outline;
    }

    Path_Visual_Factory.prototype.getPathVisual = function() {
      return this.getVisual(1, this.curve, this.width, this.color);
    };

    Path_Visual_Factory.prototype.getVisual = function(max_length, curve, width, color) {
      var fill, fill_geometry, fill_material, fill_mesh, left_line, material, middle_material, offset_amount, output, right_line, times_left, times_right, verts_left, verts_right;
      offset_amount = width / 2;
      curve.updateDiscretization(max_length);
      material = EX.style.m_default_line.clone();
      material.color = EX.style.c_default_line;
      middle_material = EX.style.m_default_line.clone();
      middle_material.color = EX.style.c_default_line;

      /*
      middle_line = new THREE.Geometry()
      middle_line.vertices = curve.getDiscretization()
       */
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = EX.style.m_flat_fill.clone();
      fill_material.color = color;
      this.fill_material = fill_material;
      output = new THREE.Object3D();
      fill = new THREE.Object3D();
      output.add(fill);
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      output.add(fill_mesh);
      if (this.show_outline) {
        output.add(new THREE.Line(left_line, material));
        output.add(new THREE.Line(right_line, material));
      }
      return output;
    };

    Path_Visual_Factory.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    Path_Visual_Factory.prototype._BDS_Polyline_to_THREE_vertex_list = function(polyline) {
      var i, len, pt, pts, vec, vecs;
      pts = polyline.toPoints();
      vecs = [];
      for (i = 0, len = pts.length; i < len; i++) {
        pt = pts[i];
        vec = new THREE.Vector3(pt.x, pt.y, pt.z);
        vecs.push(vec);
      }
      if (polyline.isClosed()) {
        pt = pts[0];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
        pt = pts[1];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      return vecs;
    };

    Path_Visual_Factory.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len = vectors.length; i < len; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    return Path_Visual_Factory;

  })();

}).call(this);
