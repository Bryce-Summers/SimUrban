// Generated by CoffeeScript 1.11.1

/*
 * Written by Bryce Summers on 10.23.2017
 * 
 * Allows THREE.js visuals to be built from polylines, polygons, strings, etc.
 */

(function() {
  EX.Visual_Factory = (function() {
    function Visual_Factory() {
      EX.Visual_Factory.unit_meshes = new EX.Unit_Meshes();
    }


    /*
         * Local Variables.
    
         * Root of THREE.JS visualization.
        @scene = new THREE.Scene()
        
         * Simple Meshes, such as circles creator.
        @unit_meshes = new BDS.Unit_Meshes(EX.style.m_flat_fill, EX.style.m_flat_fill, EX.style.m_default_line)
    
        #@init_test_scene()
        @input_root = null
    
        @init_test_bryce_image()
    
    init_test_scene: () ->
    
         * Test Line on the screen.
        pts = [new BDS.Point(0, 0), new BDS.Point(100, 100), new BDS.Point(500, 100)]
        polyline = new BDS.Polyline(false, pts)
        @newCurve(polyline, new THREE.Color(0, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(0, 200), new BDS.Point(100, 300), new BDS.Point(500, 300)]
        polyline = new BDS.Polyline(false, pts)
        @newPath(polyline, 50, new THREE.Color(1, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(500, 500), new BDS.Point(600, 500), new BDS.Point(550, 700)]
        polyline = new BDS.Polyline(false, pts)
        @newPolygon(polyline, 50, new THREE.Color(0, 0, 1))
        @newPoint(new BDS.Point(800, 350), new THREE.Color(0, 0, 1))
     */

    Visual_Factory.unit_meshes = null;

    Visual_Factory.textMeshQueue = [];

    Visual_Factory.textureLoader = new THREE.TextureLoader();

    Visual_Factory.newCurve = function(polyline, color) {
      var geom, k, len, line_material, mesh, pt, pts;
      if (polyline.size() < 2) {
        return;
      }
      geom = new THREE.Geometry();
      pts = polyline.toPoints();
      if (polyline.isClosed()) {
        pts.push(pts[0]);
      }
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        geom.vertices.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      line_material = EX.style.m_default_line.clone();
      line_material.color = color.clone();
      mesh = new THREE.Line(geom, line_material);
      return mesh;
    };

    Visual_Factory.newPath = function(polyline, width, color, show_outline) {
      var mesh, pathFactory;
      if (!show_outline) {
        show_outline = false;
      }
      if (polyline.size() < 2 || (polyline.isClosed() && polyline.size < 3)) {
        return null;
      }
      pathFactory = new EX.Path_Visual_Factory(polyline, width, color, show_outline);
      mesh = pathFactory.getPathVisual();
      return mesh;
    };

    Visual_Factory.newPolygon = function(polygon, color) {
      var geometry, k, len, material, mesh, pt, pts, shape, vecs;
      pts = polygon.toPoints();
      vecs = [];
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      shape = new THREE.Shape(vecs);
      geometry = new THREE.ShapeGeometry(shape);
      material = EX.style.m_flat_fill.clone();
      mesh = new THREE.Mesh(geometry, material);
      return mesh;
    };

    Visual_Factory.newPoint = function(pt, color, radius) {
      var material, mesh, pos, scale;
      scale = new THREE.Vector3(radius, radius, 1);
      pos = new THREE.Vector3(pt.x, pt.y, 1);
      material = EX.style.m_flat_fill.clone();
      mesh = this.unit_meshes.newCircle({
        color: color,
        material: material,
        position: pos,
        scale: scale
      });
      return mesh;
    };


    /*
    
    External API.
     */

    Visual_Factory.setInputRoot = function(input) {
      var input_root;
      return input_root = input;
    };

    Visual_Factory.getVisual = function() {
      return this.scene;
    };

    Visual_Factory.new_label = function(str) {
      var obj, params;
      obj = new THREE.Object3D();
      params = {
        font: EX.style.fontLoader,
        message: str,
        height: 20,
        out: obj,
        fill_color: 0x000000,
        outline_color: 0x111111
      };
      EX.Visual_Factory.newText(params);
      obj.position.copy(new THREE.Vector3(-50, 20, -100));
      obj.scale.copy(new THREE.Vector3(1, -1, 1));
      obj.rotation.copy(new THREE.Vector3(0, 0, Math.PI / 2));
      return obj;
    };


    /*
    EX.style.load_texture = (url) ->
        material = new THREE.MeshBasicMaterial( {
            map: null
         } );
    
        loader = new THREE.TextureLoader();
    
         * load the resource
        loader.load(
            url,
            (texture) ->
                 * Color map the material to the loaded texture.
                material.map = texture
    
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set( 40, 40);
            ,
            (xhr) ->
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )
            ,
             * Function called when download errors
            ( xhr ) ->
                console.log( "The texture at url: " + url + "  was not loaded." )
        )
    
        return material
     */

    Visual_Factory.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = EX.Visual_Factory.loader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };

    Visual_Factory.newText = function(params) {
      var geometry, message, shapes;
      if (!EX.style.font) {
        EX.Visual_Factory.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = EX.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        EX.Visual_Factory.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        EX.Visual_Factory.newOutlineText(params, shapes, geometry);
      }
      return params.out.position.z = +.1;
    };

    Visual_Factory.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      geometry.scale(1, -1, 1);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };

    Visual_Factory.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      params.out.position.z = +.1;
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.scale(1, -1, 1);
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };

    return Visual_Factory;

  })();

}).call(this);
