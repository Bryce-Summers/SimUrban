// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  TSAG.init_style = function() {
    TSAG.style = {
      radius_road_local: 50,
      radius_road_collector: 75,
      radius_road_artery: 100,
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_car_fill: new THREE.Color(0x00aaaa),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0,
      dz_cars: .02,
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000),
      action: new THREE.Color(0x72E261),
      c_normal: new THREE.Color(0xdddddd)
    };
    TSAG.style.unit_meshes = new TSAG.Unit_Meshes();

    /*
    TSAG.style.load_texture = (url) ->
        material = new THREE.MeshBasicMaterial( {
            map: null
         } );
    
        loader = new THREE.TextureLoader();
    
         * load the resource
        loader.load(
            url,
            (texture) ->
                 * Color map the material to the loaded texture.
                material.map = texture
    
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set( 40, 40);
            ,
            (xhr) ->
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )
            ,
             * Function called when download errors
            ( xhr ) ->
                console.log( "The texture at url: " + url + "  was not loaded." )
        )
    
        return material
     */
    TSAG.style.loader = new THREE.TextureLoader();
    TSAG.style.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = TSAG.style.loader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };
    TSAG.style.fontLoader = new THREE.FontLoader();
    TSAG.style.textMeshQueue = [];
    TSAG.style.fontLoader.load('fonts/Raleway_Regular.typeface.json', function(font) {
      var k, len, params, ref, results;
      TSAG.style.font = font;
      ref = TSAG.style.textMeshQueue;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        params = ref[k];
        results.push(TSAG.style.newText(params));
      }
      return results;
    });
    TSAG.style.newText = function(params) {
      var geometry, message, shapes;
      if (!TSAG.style.font) {
        TSAG.style.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = TSAG.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        TSAG.style.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        TSAG.style.newOutlineText(params, shapes, geometry);
      }
      return params.out.position.z = +.1;
    };
    TSAG.style.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      geometry.scale(1, -1, 1);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };
    return TSAG.style.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      params.out.position.z = +.1;
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.scale(1, -1, 1);
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };
  };

}).call(this);
