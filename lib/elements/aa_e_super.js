// Generated by CoffeeScript 1.11.1

/*
 *
 * Element Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Some Elements will have pointers to Scribble Elements.
 * All elements contain an @_view object that is a renderable THREE.js scene node.
 * All elements also contain an BDS.AABVH @_BVH object that stores versions of this element's geometry for collision detection.
 */

(function() {
  TSAG.E_Super = (function() {
    function E_Super(_view) {
      this._view = _view;
      if (!this._view) {
        this._view = new THREE.Object3D();
      }
      this._bvh = new BDS.BVH2D();
      this._collision_polygon = null;
      if (!this._topology) {
        this._topology = null;
      }
    }

    E_Super.prototype.isTemporary = function() {
      return this._topology === null;
    };

    E_Super.prototype.getVisual = function() {
      return this._view;
    };

    E_Super.prototype.setTopology = function(_topology) {
      this._topology = _topology;
    };

    E_Super.prototype.getTopology = function() {
      return this._topology;
    };

    E_Super.prototype.addVisual = function(subview) {
      return this._view.add(subview);
    };

    E_Super.prototype.removeVisual = function(subview) {
      return this._view.remove(subview);
    };

    E_Super.prototype.addCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.addCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.addCollisionPolygon = function(polygon) {
      return this._bvh.add(polygon);
    };

    E_Super.prototype.removeCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.removeCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.removeCollisionPolygon = function(polygon) {
      return this._bvh.remove(polygon);
    };

    E_Super.prototype.generateBVH = function() {
      var polylines;
      polylines = this._to_collision_polygons();
      return this._bvh = new BDS.BVH2D(polylines);
    };

    E_Super.prototype.generateCollisionPolygon = function() {
      this._collision_polygon = this._bvh.toBoundingBox().toPolyline();
      this._collision_polygon.setAssociatedData(this);
      return this._collision_polygon;
    };

    E_Super.prototype.getCollisionPolygon = function() {
      if (this._collision_polygon === null) {
        this.generateCollisionPolygon();
      }
      return this._collision_polygon;
    };

    E_Super.prototype._to_collision_polygons = function(output) {
      var a, b, c, face, faces, geometry, i, j, len, len1, localToWorld, mesh, mesh_list, obj, polyline, polyline_list, vertices;
      obj = this._view;
      mesh_list = this._to_mesh_list(obj);
      polyline_list = [];
      if (output !== void 0) {
        polyline_list = output;
      }
      for (i = 0, len = mesh_list.length; i < len; i++) {
        mesh = mesh_list[i];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (j = 0, len1 = faces.length; j < len1; j++) {
          face = faces[j];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          a = this._vector_to_point(a);
          b = this._vector_to_point(b);
          c = this._vector_to_point(c);
          polyline = new BDS.Polyline(true, [a, b, c]);
          polyline.setAssociatedData(this);
          polyline_list.push(polyline);
        }
      }
      return polyline_list;
    };

    E_Super.prototype._vector_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y, vec.z);
    };

    E_Super.prototype._to_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    E_Super.prototype.setFillColor = function(c) {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.revertFillColor = function() {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.setPosition = function(position) {
      var z;
      z = this._view.position.z;
      this._view.position.copy(position.clone());
      return this._view.position.z = z;
    };

    E_Super.prototype.setRotation = function(rotation_z) {
      return this._view.rotation.z = rotation_z;
    };

    E_Super.prototype.getRotation = function() {
      return this._view.rotation.z;
    };

    E_Super.prototype.setScale = function(scale) {
      return this._view.scale.copy(scale.clone());
    };

    E_Super.prototype.getPosition = function() {
      return this._view.position.clone();
    };

    E_Super.prototype.getAgents = function(out) {
      throw new Error("Destroy is unimplemented for this element!!!");
    };

    E_Super.prototype.containsPt = function(pt) {
      return this._bvh.query_point(pt) !== null;
    };

    return E_Super;

  })();

}).call(this);
