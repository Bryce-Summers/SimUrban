// Generated by CoffeeScript 1.11.1

/*

Lane Elements

Written by Bryce Summers on 2 - 1 - 2017.

Purpose: This class contains handles the movement of cars along a lane.

queues cars through lane.
Parameterizes car movement:
 - t space [0:start, 1:end]      # Percentage space, needed for coorespondence with alternate lanes.
 - s space [0:start, length:end] # Distance space,   needed for realistic movement of vehicles.
 */

(function() {
  TSAG.S_Lane = (function() {
    function S_Lane(polyline, reverse) {
      this.cars = new BDS.SingleLinkedList();
      if (reverse) {
        polyline.reverse();
      }
      this.cumulative_lengths = polyline.computeCumulativeLengths();
      this.angles = polyline.computeTangentAngles();
      this.tangents = polyline.computeUnitTangents();
      this.points = polyline.toPoints();
    }

    S_Lane.prototype.addCar = function(car) {
      return this.cars.enqueue(car);
    };

    S_Lane.prototype.moveCars = function() {
      var car, destroyed_cars, iter;
      destroyed_cars = [];
      iter = this.cars.iterator();
      while (iter.hasNext()) {
        car = iter.next();
        if (!this._moveCar(car, 1)) {
          iter.remove();
          destroyed_cars.push(car);
        }
      }
      return destroyed_cars;
    };

    S_Lane.prototype._accelerateCar = function(car) {};

    S_Lane.prototype._moveCar = function(car, change_in_distance) {
      var car_position, index, local_distance, local_point, local_tangent, next_length;
      index = car.segment_index;
      car.distance += change_in_distance;
      while (true) {
        next_length = this.cumulative_lengths[index + 1];
        if (!(car.distance >= next_length)) {
          break;
        }
        index += 1;
        if (index === this.cumulative_lengths.length) {
          return false;
        }
      }
      if (index >= this.points.length - 1) {
        return false;
      }
      local_distance = car.distance - this.cumulative_lengths[index];
      local_point = this.points[index];
      local_tangent = this.tangents[index];
      if (!local_tangent) {
        debugger;
      }
      car_position = local_point.add(local_tangent.multScalar(local_distance));
      car.setPosition(car_position);
      car.segment_index = index;
      car.setRotation(this.angles[index]);
      return true;
    };

    return S_Lane;

  })();

}).call(this);
