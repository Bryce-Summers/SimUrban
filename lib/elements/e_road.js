// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Road = (function(superClass) {
    extend(E_Road, superClass);

    function E_Road() {
      var visual;
      E_Road.__super__.constructor.call(this);
      this._main_curve = new TSAG.S_Curve();
      visual = this.getVisual();
      visual.position.z = TSAG.style.dz_road;
      this.fill_material = TSAG.style.m_default_fill.clone();
      this._road_visual = null;
      this._center_polyline = null;
      this.lanes = [];
      this.vert_start = null;
      this.vert_end = null;
      this.halfedge = null;
      this.reverts = [];
    }

    E_Road.prototype.setStartVertex = function(vert) {
      return this.vert_start = vert;
    };

    E_Road.prototype.getStartVertex = function() {
      return this.vert_start;
    };

    E_Road.prototype.setHalfedge = function(halfedge) {
      return this.halfedge = halfedge;
    };

    E_Road.prototype.getHalfedge = function() {
      return this.halfedge;
    };

    E_Road.prototype.setEndVertex = function(vert) {
      return this.vert_end = vert;
    };

    E_Road.prototype.getEndVertex = function() {
      return this.vert_end;
    };

    E_Road.prototype.hasEndPoint = function(vert) {
      return this.vert_start === vert || this.vert_end === vert;
    };

    E_Road.prototype.addPoint = function(pt) {
      this._main_curve.addPoint(pt);
      return true;
    };

    E_Road.prototype.getLastPoint = function() {
      return this._main_curve.getLastPoint();
    };

    E_Road.prototype.getPenultimatePoint = function() {
      var len;
      len = this._main_curve.numPoints();
      return this._main_curve.getPointAtIndex(len - 2);
    };

    E_Road.prototype.numPoints = function() {
      return this._main_curve.numPoints();
    };

    E_Road.prototype.getPointAtIndexFromEnd = function(index) {
      var len;
      len = this._main_curve.numPoints();
      return this._main_curve.getPointAtIndex(len - 1 - index);
    };

    E_Road.prototype.removeLastPoint = function() {
      return this._main_curve.removeLastPoint();
    };

    E_Road.prototype.setRevert = function() {
      return this.reverts.push({
        index: this._main_curve.numPoints(),
        point2: this.getLastPoint(),
        point1: this.getPenultimatePoint()
      });
    };

    E_Road.prototype.revert = function() {
      var revert_obj;
      revert_obj = this.revertObj();
      while (this._main_curve.numPoints() > revert_obj.index - 2) {
        this.removeLastPoint();
      }
      this.addPoint(revert_obj.point1);
      return this.addPoint(revert_obj.point2);
    };

    E_Road.prototype.revertObj = function() {
      return this.reverts[this.reverts.length - 1];
    };

    E_Road.prototype.updateLastPoint = function(pt) {
      this.removeLastPoint();
      return this.addPoint(pt);
    };

    E_Road.prototype.getPosition = function(time) {
      return this._main_curve.position(time);
    };

    E_Road.prototype.updateDiscretization = function(max_length) {
      this.updateVisual(max_length);
      return this.generateBVH();
    };

    E_Road.prototype.updateVisual = function(max_length) {
      var fill_geometry, fill_material, fill_mesh, left_line, material, middle_line, middle_material, offset_amount, right_line, times_left, times_right, verts_left, verts_right, visual;
      offset_amount = TSAG.style.road_offset_amount;
      this._main_curve.updateDiscretization(max_length);
      visual = this.getVisual();
      visual.remove(this._road_visual);
      this._road_visual = new THREE.Object3D();
      visual.add(this._road_visual);
      material = TSAG.style.m_default_line.clone();
      material.color = TSAG.style.c_road_outline;
      middle_material = TSAG.style.m_default_line.clone();
      middle_material.color = TSAG.style.c_road_midline;
      middle_line = new THREE.Geometry();
      middle_line.vertices = this._main_curve.getDiscretization();
      this._center_polyline = this._THREE_vertex_list_to_BDS_Polyline(middle_line.vertices);
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = this._main_curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = this._main_curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = TSAG.style.m_default_fill.clone();
      fill_material.color = TSAG.style.c_road_fill;
      this.fill_material = fill_material;
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      this._road_visual.add(fill_mesh);
      this._road_visual.add(new THREE.Line(middle_line, middle_material));
      this._road_visual.add(new THREE.Line(left_line, material));
      this._road_visual.add(new THREE.Line(right_line, material));
      return this.updateLaneStructures(max_length, offset_amount, times_left, times_right);
    };

    E_Road.prototype.updateLaneStructures = function(max_length, offset_amount, times_left, times_right) {
      var left_lane, left_lane_polyline, left_lane_vectors, right_lane, right_lane_polyline, right_lane_vectors;
      left_lane_vectors = this._main_curve.getOffsets(max_length, offset_amount / 2, times_left);
      right_lane_vectors = this._main_curve.getOffsets(max_length, -offset_amount / 2, times_right);
      left_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(left_lane_vectors);
      right_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(right_lane_vectors);
      right_lane = new TSAG.S_Lane(right_lane_polyline, false, this.vert_start, this.vert_end);
      left_lane = new TSAG.S_Lane(left_lane_polyline, true, this.vert_end, this.vert_start);
      this.lanes = [];
      this.lanes.push(right_lane);
      return this.lanes.push(left_lane);
    };

    E_Road.prototype.setFillColor = function(c) {
      return this.fill_material.color = c;
    };

    E_Road.prototype.revertFillColor = function() {
      return this.fill_material.color = TSAG.style.c_road_fill;
    };

    E_Road.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    E_Road.prototype.getCenterPolyline = function() {
      return this._center_polyline;
    };

    E_Road.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len1, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len1 = vectors.length; i < len1; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    E_Road.prototype.getLanes = function() {
      return this.lanes;
    };

    E_Road.prototype.getAgents = function(out) {
      var i, lane, len1, ref, results;
      ref = this.lanes;
      results = [];
      for (i = 0, len1 = ref.length; i < len1; i++) {
        lane = ref[i];
        results.push(lane.getAgents(out));
      }
      return results;
    };

    E_Road.prototype.addCar = function(car, vert) {
      if (vert === this.vert_start) {
        return this.lanes[0].addCar(car);
      } else {
        return this.lanes[1].addCar(car);
      }
    };

    E_Road.prototype.getWidth = function() {
      return TSAG.style.road_offset_amount * this.lanes.length;
    };

    E_Road.prototype.getClosePointOnCenterLine = function(pt) {
      var dir, end_vertex, half_width, halfedge, p1, p2, par, perp, pt_on_road, ray, ref, v1, v2;
      halfedge = this.getHalfedge();
      end_vertex = this.getEndVertex();
      half_width = this.getWidth() / 2;
      while (halfedge.vertex !== end_vertex) {
        v1 = halfedge.vertex;
        v2 = halfedge.twin.vertex;
        p1 = v1.data.point;
        p2 = v2.data.point;
        dir = p2.sub(p1);
        ray = new BDS.Ray(p1, dir);
        ref = ray.getPerpAndParLengths(pt), perp = ref[0], par = ref[1];
        if (perp <= half_width + .1 && par >= 0 && par <= 1) {
          pt_on_road = ray.getPointAtTime(par);
          return [pt_on_road, halfedge.edge];
        }
        halfedge = halfedge.next;
      }
      return [null, null];
    };

    E_Road.prototype.getCost = function() {
      return this._main_curve.length();
    };

    return E_Road;

  })(TSAG.E_Super);

}).call(this);
