// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Road = (function(superClass) {
    extend(E_Road, superClass);

    function E_Road() {
      var visual;
      E_Road.__super__.constructor.call(this);
      this._main_curve = new TSAG.S_Curve();
      visual = this.getVisual();
      visual.position.z = TSAG.style.dz_road;
      this._road_visual = null;
      this._center_polyline = null;
      this.lanes = [];
    }

    E_Road.prototype.addPoint = function(pt) {
      this._main_curve.addPoint(pt);
      return true;
    };

    E_Road.prototype.getLastPoint = function() {
      return this._main_curve.getLastPoint();
    };

    E_Road.prototype.removeLastPoint = function() {
      return this._main_curve.removeLastPoint();
    };

    E_Road.prototype.updateLastPoint = function(pt) {
      this.removeLastPoint();
      return this.addPoint(pt);
    };

    E_Road.prototype.getPosition = function(time) {
      return this._main_curve.position(time);
    };

    E_Road.prototype.updateDiscretization = function(max_length) {
      this.updateVisual(max_length);
      return this.generateBVH();
    };

    E_Road.prototype.updateVisual = function(max_length) {
      var fill_geometry, fill_material, fill_mesh, left_line, material, middle_line, middle_material, offset_amount, right_line, times_left, times_right, verts_left, verts_right, visual;
      offset_amount = TSAG.style.road_offset_amount;
      this._main_curve.updateDiscretization(max_length);
      visual = this.getVisual();
      visual.remove(this._road_visual);
      this._road_visual = new THREE.Object3D();
      visual.add(this._road_visual);
      material = TSAG.style.m_default_line.clone();
      material.color = TSAG.style.c_road_outline;
      middle_material = TSAG.style.m_default_line.clone();
      middle_material.color = TSAG.style.c_road_midline;
      middle_line = new THREE.Geometry();
      middle_line.vertices = this._main_curve.getDiscretization();
      this._center_polyline = this._THREE_vertex_list_to_BDS_Polyline(middle_line.vertices);
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = this._main_curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = this._main_curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = TSAG.style.m_default_fill.clone();
      fill_material.color = TSAG.style.c_road_fill;
      this.fill_material = fill_material;
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      this._road_visual.add(fill_mesh);
      this._road_visual.add(new THREE.Line(middle_line, middle_material));
      this._road_visual.add(new THREE.Line(left_line, material));
      this._road_visual.add(new THREE.Line(right_line, material));
      return this.updateLaneStructures(max_length, offset_amount, times_left, times_right);
    };

    E_Road.prototype.updateLaneStructures = function(max_length, offset_amount, times_left, times_right) {
      var left_lane, left_lane_polyline, left_lane_vectors, right_lane, right_lane_polyline, right_lane_vectors;
      left_lane_vectors = this._main_curve.getOffsets(max_length, offset_amount / 2, times_left);
      right_lane_vectors = this._main_curve.getOffsets(max_length, -offset_amount / 2, times_right);
      left_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(left_lane_vectors);
      right_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(right_lane_vectors);
      left_lane = new TSAG.S_Lane(left_lane_polyline, true);
      right_lane = new TSAG.S_Lane(right_lane_polyline, false);
      this.lanes = [];
      this.lanes.push(left_lane);
      return this.lanes.push(right_lane);
    };

    E_Road.prototype.setFillColor = function(c) {
      return this.fill_material.color = c;
    };

    E_Road.prototype.revertFillColor = function() {
      return this.fill_material.color = TSAG.style.c_road_fill;
    };

    E_Road.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    E_Road.prototype.getCenterPolyline = function() {
      return this._center_polyline;
    };

    E_Road.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len = vectors.length; i < len; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    E_Road.prototype.getLanes = function() {
      return this.lanes;
    };

    E_Road.prototype.getWidth = function() {
      return TSAG.style.road_offset_amount * this.lanes.length;
    };

    return E_Road;

  })(TSAG.E_Super);

}).call(this);
