/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 08-03-2017
 */
/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
TSAG = {};

// Generated by CoffeeScript 1.11.1

/*
 *
 * Element Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Some Elements will have pointers to Scribble Elements.
 * All elements contain an @_view object that is a renderable THREE.js scene node.
 * All elements also contain an BDS.AABVH @_BVH object that stores versions of this element's geometry for collision detection.
 */

(function() {
  TSAG.E_Super = (function() {
    function E_Super(_view) {
      this._view = _view;
      if (!this._view) {
        this._view = new THREE.Object3D();
      }
      this._bvh = new BDS.BVH2D();
      this._collision_polygon = null;
      if (!this._topology) {
        this._topology = null;
      }
    }

    E_Super.prototype.isTemporary = function() {
      return this._topology === null;
    };

    E_Super.prototype.getVisual = function() {
      return this._view;
    };

    E_Super.prototype.setTopology = function(_topology) {
      this._topology = _topology;
    };

    E_Super.prototype.getTopology = function() {
      return this._topology;
    };

    E_Super.prototype.addVisual = function(subview) {
      return this._view.add(subview);
    };

    E_Super.prototype.removeVisual = function(subview) {
      return this._view.remove(subview);
    };

    E_Super.prototype.addCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.addCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.addCollisionPolygon = function(polygon) {
      return this._bvh.add(polygon);
    };

    E_Super.prototype.removeCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.removeCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.removeCollisionPolygon = function(polygon) {
      return this._bvh.remove(polygon);
    };

    E_Super.prototype.generateBVH = function() {
      var polylines;
      polylines = this.to_collision_polygons();
      return this._bvh = new BDS.BVH2D(polylines);
    };

    E_Super.prototype.generateCollisionPolygon = function() {
      this._collision_polygon = this._bvh.toBoundingBox().toPolyline();
      return this._collision_polygon;
    };

    E_Super.prototype.getCollisionPolygon = function() {
      if (this._collision_polygon === null) {
        this.generateCollisionPolygon();
      }
      return this._collision_polygon;
    };

    E_Super.prototype.to_collision_polygons = function(output) {
      var a, b, c, face, faces, geometry, i, j, len, len1, localToWorld, mesh, mesh_list, obj, polyline, polyline_list, vertices;
      obj = this._view;
      mesh_list = this._to_mesh_list(obj);
      polyline_list = [];
      if (output !== void 0) {
        polyline_list = output;
      }
      for (i = 0, len = mesh_list.length; i < len; i++) {
        mesh = mesh_list[i];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (j = 0, len1 = faces.length; j < len1; j++) {
          face = faces[j];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          a = this._vector_to_point(a);
          b = this._vector_to_point(b);
          c = this._vector_to_point(c);
          polyline = new BDS.Polyline(true, [a, b, c]);
          polyline.setAssociatedData(this);
          polyline_list.push(polyline);
        }
      }
      return polyline_list;
    };

    E_Super.prototype._vector_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y, vec.z);
    };

    E_Super.prototype._to_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    E_Super.prototype.setFillColor = function(c) {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.revertFillColor = function() {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.setPosition = function(position) {
      var z;
      z = this._view.position.z;
      this._view.position.copy(position.clone());
      return this._view.position.z = z;
    };

    E_Super.prototype.setRotation = function(rotation_z) {
      return this._view.rotation.z = rotation_z;
    };

    E_Super.prototype.setScale = function(scale) {
      return this._view.scale.copy(scale.clone());
    };

    return E_Super;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Area element.

Game elements that are topologically associated with faces.
 */

(function() {


}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Building Element Class.
 * 
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Purpose: This class specifies the gameplay and aesthetic properties of building objects.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Building = (function(superClass) {
    extend(E_Building, superClass);

    function E_Building(position, scale, rotation_z) {
      var _position, _rz, mesh, view;
      E_Building.__super__.constructor.call(this);
      view = this.getVisual();
      _position = position;
      _rz = rotation_z;
      mesh = this._newHouse({
        color: TSAG.style.c_building_fill
      });
      mesh.position.copy(position.clone());
      mesh.scale.copy(scale.clone());
      mesh.rotation.z = rotation_z;
      this._mesh = mesh;
      view.add(mesh);
    }

    E_Building.prototype._newHouse = function(params) {
      var mesh_factory, node, square, triangle;
      mesh_factory = TSAG.style.unit_meshes;
      square = mesh_factory.newSquare(params);
      triangle = mesh_factory.newTriangle(params);
      triangle.position.x = .5;
      triangle.scale.x = .5;
      node = new THREE.Object3D();
      node.add(square);
      node.add(triangle);
      return node;
    };

    E_Building.prototype.rotateBuilding = function(dr) {
      this.getVisual().remove(this._mesh);
      this._mesh.rotation.z = this._mesh.rotation.z + dr;
      return this.getVisual().add(this._mesh);
    };

    return E_Building;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Car Element Class.
 * 
 * Written by Bryce Summers on 1 - 31 - 2017.
 *
 * Purpose: This class specifies the gameplay and aesthetic properties of building objects.
 *
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Car = (function(superClass) {
    extend(E_Car, superClass);

    function E_Car(scale) {
      E_Car.__super__.constructor.call(this);
      this.createVisual(scale);
      this.distance = 0.0;
      this.segment_index = 0;
      this.next_car = null;
    }

    E_Car.prototype.createVisual = function(scale) {
      var mesh, view;
      view = this.getVisual();
      mesh = this._newCar({
        color: TSAG.style.c_car_fill
      });
      view.add(mesh);
      view.position.z = TSAG.style.dz_cars;
      return this.setScale(scale);
    };

    E_Car.prototype._newCar = function(params) {
      var mesh_factory, square;
      mesh_factory = TSAG.style.unit_meshes;
      square = mesh_factory.newSquare(params);
      square.scale.x = 2;
      return square;
    };

    return E_Car;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Intersection = (function(superClass) {
    extend(E_Intersection, superClass);

    function E_Intersection(position) {
      var fill, sx, sy, view;
      E_Intersection.__super__.constructor.call(this);
      this._position = position;
      fill = TSAG.style.unit_meshes.newSquare({
        color: TSAG.style.c_road_fill
      });
      fill.position.copy(new THREE.Vector3(position.x, position.y, 0));
      sx = sy = TSAG.style.road_offset_amount * 2;
      fill.scale.copy(new THREE.Vector3(sx, sy, 1));
      view = this.getVisual();
      view.add(fill);
      view.position.z = TSAG.style.dz_intersection;
      this.generateBVH();
    }

    E_Intersection.prototype.addRoad = function(road) {
      var edge;
      edge = road.getEdge();
      return true;
    };

    E_Intersection.prototype.getPoint = function() {
      return this._position.clone();
    };

    return E_Intersection;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Network = (function(superClass) {
    extend(E_Network, superClass);

    function E_Network() {
      var graph;
      E_Network.__super__.constructor.call(this);
      this._topology_generator = new TSAG.PolylineGraphGenerator();
      graph = this._topology_generator.allocateGraph();
      this._topology_linker = new SCRIB.TopologyLinker(this._topology_generator, graph);
      this.setTopology(graph);
      this._roads = [];
    }

    E_Network.prototype.addRoad = function(road) {
      return this._roads.push(road);
    };

    E_Network.prototype.getRoads = function() {
      return this._roads;
    };

    E_Network.prototype.getGenerator = function() {
      return this._topology_generator;
    };

    E_Network.prototype.getLinker = function() {
      return this._topology_linker;
    };

    E_Network.prototype.query_elements_pt = function(x, y) {
      var elements, i, len, polyline, polylines;
      polylines = this._bvh.query_point_all(new BDS.Point(x, y));
      elements = [];
      for (i = 0, len = polylines.length; i < len; i++) {
        polyline = polylines[i];
        elements.push(polyline.getAssociatedData());
      }
      return elements;
    };

    E_Network.prototype.query_elements_box = function(box) {
      var elements, i, len, polyline, polylines;
      polylines = this._bvh.query_box_all(box);
      elements = [];
      for (i = 0, len = polylines.length; i < len; i++) {
        polyline = polylines[i];
        elements.push(polyline.getAssociatedData());
      }
      return elements;
    };

    return E_Network;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Road = (function(superClass) {
    extend(E_Road, superClass);

    function E_Road() {
      var visual;
      E_Road.__super__.constructor.call(this);
      this._main_curve = new TSAG.S_Curve();
      visual = this.getVisual();
      visual.position.z = TSAG.style.dz_road;
      this._road_visual = null;
      this._center_polyline = null;
      this.lanes = [];
    }

    E_Road.prototype.addPoint = function(pt) {
      this._main_curve.addPoint(pt);
      return true;
    };

    E_Road.prototype.getLastPoint = function() {
      return this._main_curve.getLastPoint();
    };

    E_Road.prototype.removeLastPoint = function() {
      return this._main_curve.removeLastPoint();
    };

    E_Road.prototype.updateLastPoint = function(pt) {
      this.removeLastPoint();
      return this.addPoint(pt);
    };

    E_Road.prototype.getPosition = function(time) {
      return this._main_curve.position(time);
    };

    E_Road.prototype.updateDiscretization = function(max_length) {
      this.updateVisual(max_length);
      return this.generateBVH();
    };

    E_Road.prototype.updateVisual = function(max_length) {
      var fill_geometry, fill_material, fill_mesh, left_line, material, middle_line, middle_material, offset_amount, right_line, times_left, times_right, verts_left, verts_right, visual;
      offset_amount = TSAG.style.road_offset_amount;
      this._main_curve.updateDiscretization(max_length);
      visual = this.getVisual();
      visual.remove(this._road_visual);
      this._road_visual = new THREE.Object3D();
      visual.add(this._road_visual);
      material = TSAG.style.m_default_line.clone();
      material.color = TSAG.style.c_road_outline;
      middle_material = TSAG.style.m_default_line.clone();
      middle_material.color = TSAG.style.c_road_midline;
      middle_line = new THREE.Geometry();
      middle_line.vertices = this._main_curve.getDiscretization();
      this._center_polyline = this._THREE_vertex_list_to_BDS_Polyline(middle_line.vertices);
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = this._main_curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = this._main_curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = TSAG.style.m_default_fill.clone();
      fill_material.color = TSAG.style.c_road_fill;
      this.fill_material = fill_material;
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      this._road_visual.add(fill_mesh);
      this._road_visual.add(new THREE.Line(middle_line, middle_material));
      this._road_visual.add(new THREE.Line(left_line, material));
      this._road_visual.add(new THREE.Line(right_line, material));
      return this.updateLaneStructures(max_length, offset_amount, times_left, times_right);
    };

    E_Road.prototype.updateLaneStructures = function(max_length, offset_amount, times_left, times_right) {
      var left_lane, left_lane_polyline, left_lane_vectors, right_lane, right_lane_polyline, right_lane_vectors;
      left_lane_vectors = this._main_curve.getOffsets(max_length, offset_amount / 2, times_left);
      right_lane_vectors = this._main_curve.getOffsets(max_length, -offset_amount / 2, times_right);
      left_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(left_lane_vectors);
      right_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(right_lane_vectors);
      left_lane = new TSAG.S_Lane(left_lane_polyline, true);
      right_lane = new TSAG.S_Lane(right_lane_polyline, false);
      this.lanes = [];
      this.lanes.push(left_lane);
      return this.lanes.push(right_lane);
    };

    E_Road.prototype.setFillColor = function(c) {
      return this.fill_material.color = c;
    };

    E_Road.prototype.revertFillColor = function() {
      return this.fill_material.color = TSAG.style.c_road_fill;
    };

    E_Road.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    E_Road.prototype.getCenterPolyline = function() {
      return this._center_polyline;
    };

    E_Road.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len = vectors.length; i < len; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    E_Road.prototype.getLanes = function() {
      return this.lanes;
    };

    E_Road.prototype.getWidth = function() {
      return TSAG.style.road_offset_amount * this.lanes.length;
    };

    return E_Road;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban Scene Object.
    Written by Bryce on 11/22/2016
    Refactored by Bryce on 12 - 18 - 2016.
    
    Purpose: This class organizes all of the structural layers in the game.
        It serves as the root of the scene graph for all rendering.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Scene = (function(superClass) {
    extend(E_Scene, superClass);

    function E_Scene(scene_width, scene_height) {
      var view;
      E_Scene.__super__.constructor.call(this, new THREE.Scene());
      view = this.getVisual();
      this._network = new TSAG.E_Network();
      view.add(this._network.getVisual());
      this._overlays = new THREE.Object3D();
      this._overlays.name = "Overlays";
      view.add(this._overlays);
    }

    E_Scene.prototype.constructRandomBuildings = function() {
      var building, h, i, j, pos, rz, scale, w, x, y;
      this._building_visuals = new THREE.Object3D();
      this._building_visuals.name = "Building Visuals";
      view.add(this._building_visuals);
      this._buildings = [];
      this._scale = 40;
      this._padding = 30;
      for (i = j = 0; j < 10; i = ++j) {
        x = this._padding + Math.random() * (scene_width - this._padding * 2);
        y = this._padding + Math.random() * (scene_height - this._padding * 2);
        w = this._scale;
        h = this._scale;
        rz = Math.random() * Math.PI * 2;
        pos = new THREE.Vector3(x, y, 0);
        scale = new THREE.Vector3(w, h, 1);
        building = new TSAG.E_Building(pos, scale, rz);
        this._buildings.push(building);
        this._building_visuals.add(building.getVisual());
      }
    };

    E_Scene.prototype.addOverlayVisual = function(obj) {
      return this._overlays.add(obj);
    };

    E_Scene.prototype.removeOverlayVisual = function(obj) {
      return this._overlays.remove(obj);
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.getMeshFactory = function() {
      return TSAG.style.unit_meshes;
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.getBuildings = function() {
      return this._buildings;
    };

    E_Scene.prototype.getRoads = function() {
      return this._roads;
    };

    return E_Scene;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Lane Elements

Written by Bryce Summers on 2 - 1 - 2017.

Purpose: This class contains handles the movement of cars along a lane.

queues cars through lane.
Parameterizes car movement:
 - t space [0:start, 1:end]      # Percentage space, needed for coorespondence with alternate lanes.
 - s space [0:start, length:end] # Distance space,   needed for realistic movement of vehicles.
 */

(function() {
  TSAG.S_Lane = (function() {
    function S_Lane(polyline, reverse) {
      this.cars = new BDS.SingleLinkedList();
      if (reverse) {
        polyline.reverse();
      }
      this.cumulative_lengths = polyline.computeCumulativeLengths();
      this.angles = polyline.computeTangentAngles();
      this.tangents = polyline.computeUnitTangents();
      this.points = polyline.toPoints();
    }

    S_Lane.prototype.addCar = function(car) {
      return this.cars.enqueue(car);
    };

    S_Lane.prototype.moveCars = function() {
      var car, destroyed_cars, iter;
      destroyed_cars = [];
      iter = this.cars.iterator();
      while (iter.hasNext()) {
        car = iter.next();
        if (!this._moveCar(car, 1)) {
          iter.remove();
          destroyed_cars.push(car);
        }
      }
      return destroyed_cars;
    };

    S_Lane.prototype._accelerateCar = function(car) {};

    S_Lane.prototype._moveCar = function(car, change_in_distance) {
      var car_position, index, local_distance, local_point, local_tangent, next_length;
      index = car.segment_index;
      car.distance += change_in_distance;
      while (true) {
        next_length = this.cumulative_lengths[index + 1];
        if (!(car.distance >= next_length)) {
          break;
        }
        index += 1;
        if (index === this.cumulative_lengths.length) {
          return false;
        }
      }
      if (index >= this.points.length - 1) {
        return false;
      }
      local_distance = car.distance - this.cumulative_lengths[index];
      local_point = this.points[index];
      local_tangent = this.tangents[index];
      if (!local_tangent) {
        debugger;
      }
      car_position = local_point.add(local_tangent.multScalar(local_distance));
      car.setPosition(car_position);
      car.segment_index = index;
      car.setRotation(this.angles[index]);
      return true;
    };

    return S_Lane;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Top down Input Controller class.
Specifies an aggregated controller.

Written by Bryce Summers on 1 - 31 - 2017.

FIXME: Allow people to toggle certain sub-controllers on and off.
 */

(function() {
  TSAG.Input_Controller = (function() {
    function Input_Controller() {
      this._mouse_input_controllers = [];
      this._keyboard_input_controllers = [];
      this._time_input_controllers = [];
      this._system_controllers = [];
      this.time_on = false;
    }

    Input_Controller.prototype.add_universal_controller = function(controller) {
      this._mouse_input_controllers.push(controller);
      this._keyboard_input_controllers.push(controller);
      this._time_input_controllers.push(controller);
      this._system_controllers.push(controller);
    };

    Input_Controller.prototype.add_mouse_input_controller = function(controller) {
      this._mouse_input_controllers.push(controller);
    };

    Input_Controller.prototype.add_keyboard_input_controller = function(controller) {
      this._keyboard_input_controllers.push(controller);
    };

    Input_Controller.prototype.add_time_input_controller = function(controller) {
      this._time_input_controllers.push(controller);
    };

    Input_Controller.prototype.add_system_controller = function(controller) {
      this._system_controllers.push(controller);
    };

    Input_Controller.prototype.mouse_down = function(event) {
      var controller, i, j, len, ref;
      len = this._mouse_input_controllers.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        controller = this._mouse_input_controllers[i];
        controller.mouse_down(event);
      }
    };

    Input_Controller.prototype.mouse_up = function(event) {
      var controller, i, j, len, ref;
      len = this._mouse_input_controllers.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        controller = this._mouse_input_controllers[i];
        controller.mouse_up(event);
      }
    };

    Input_Controller.prototype.mouse_move = function(event) {
      var controller, i, j, len, ref;
      len = this._mouse_input_controllers.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        controller = this._mouse_input_controllers[i];
        controller.mouse_move(event);
      }
    };

    Input_Controller.prototype.time = function(dt) {
      var controller, i, j, len, ref;
      len = this._time_input_controllers.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        controller = this._time_input_controllers[i];
        controller.time(dt);
      }
    };

    Input_Controller.prototype.window_resize = function(event) {
      var controller, i, j, len, ref;
      len = this._system_controllers.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        controller = this._system_controllers[i];
        controller.window_resize();
      }
    };

    return Input_Controller;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_All_Main = (function(superClass) {
    extend(I_All_Main, superClass);

    function I_All_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_All_Main.__super__.constructor.call(this);
      this._mouse_input = new TSAG.I_Mouse_Main(this.scene, this.camera);
      this.add_mouse_input_controller(this._mouse_input);
      this._time_input = new TSAG.I_Time_Main(this.scene, this.camera);
      this.add_time_input_controller(this._time_input);
    }

    return I_All_Main;

  })(TSAG.Input_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.legal = false;
      this.next_point = null;
      this.network = this.e_scene.getNetwork();
      this.generator = this.network.getGenerator();
      this.linker = this.network.getLinker();
      this.isects = [];
      this.isects_last_segment = [];
    }

    I_Mouse_Build_Road.prototype.isIdle = function() {
      return this.state === "idle";
    };

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, i, intersection, isect, isect_pt, len, pos, ref, start_element, x, y;
      if (this.state === "idle") {
        this.road = new TSAG.E_Road();
        this.network.addVisual(this.road.getVisual());
        x = event.x;
        y = event.y;
        start_element = this._getIsectOrRoadAtPt(x, y);
        if (start_element instanceof TSAG.E_Intersection) {
          isect_pt = start_element.getPoint();
          x = isect_pt.x;
          y = isect_pt.y;
          this.isects.push({
            isect: start_element,
            type: 'p'
          });
        } else if (start_element instanceof TSAG.E_Road) {
          intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
          this.network.addVisual(intersection.getVisual());
          this.isects.push({
            isect: intersection,
            type: 's',
            road: start_element
          });
        } else {
          intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
          this.network.addVisual(intersection.getVisual());
          this.isects.push({
            isect: intersection,
            type: 'i'
          });
        }
        this.road.addPoint(new THREE.Vector3(x, y, 0));
        this.next_point = new THREE.Vector3(x, y + 1, 0);
        this.road.addPoint(this.next_point);
        this.state = "building";
        this._mousePrevious.x = event.x;
        return this._mousePrevious.y = event.y;
      } else if (this.state === "building") {
        if (!this.legal) {
          return;
        }
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          this.road.updateLastPoint(pos);
          this.next_point = new THREE.Vector3(event.x + .01, event.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          this._mousePrevious.y = event.y;
          ref = this.isects_last_segment;
          for (i = 0, len = ref.length; i < len; i++) {
            isect = ref[i];
            this.isects.push(isect);
          }
          return this.isects_last_segment = [];
        } else {
          return this.finish();
        }
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var max_length;
      if (this.state === "building") {
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        this.road.updateLastPoint(this.next_point);
        max_length = TSAG.style.discretization_length;
        this.road.updateDiscretization(max_length);
        return this.updateTemporaryRoad();
      }
    };

    I_Mouse_Build_Road.prototype.finish = function() {
      var end_element, end_pt, i, intersection, isect, isect_obj, isect_pt, j, len, len1, max_length, ref, ref1, x, y;
      if (this.state !== "building") {
        return;
      }
      this.road.removeLastPoint();
      this.state = "idle";
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      end_pt = this.road.getLastPoint();
      x = end_pt.x;
      y = end_pt.y;
      end_element = this._getIsectOrRoadAtPt(end_pt.x, end_pt.y);
      if (end_element instanceof TSAG.E_Intersection) {
        isect_pt = end_element.getPoint();
        x = isect_pt.x;
        y = isect_pt.y;
        this.isects.push({
          isect: end_element,
          type: 'p'
        });
      } else if (end_element instanceof TSAG.E_Road) {
        intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
        this.isects.push({
          isect: intersection,
          type: 's',
          road: end_element
        });
      } else {
        intersection = new TSAG.E_Intersection(new BDS.Point(x, y));
        this.isects.push({
          isect: intersection,
          type: 'i'
        });
      }
      this.network.removeVisual(this.road.getVisual());
      ref = this.isects;
      for (i = 0, len = ref.length; i < len; i++) {
        isect_obj = ref[i];
        if (isect_obj.type !== 'p') {
          this.network.removeVisual(isect_obj.isect.getVisual());
        }
      }
      this.network.addCollisionPolygons(this.road.to_collision_polygons());
      ref1 = this.isects;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        isect_obj = ref1[j];
        isect = isect_obj.isect;
        this.network.addCollisionPolygon(isect.getCollisionPolygon());
      }
      this.network.addRoad(this.road);
      this.road = null;
      this.isects = [];
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.updateTemporaryRoad = function() {
      this.destroyLastSegmentIsects();
      if (!this.checkLegality()) {
        this.road.setFillColor(TSAG.style.error);
        this.legal = false;
        return;
      }
      this.road.revertFillColor();
      this.legal = true;
      return this.createTempIntersections();
    };

    I_Mouse_Build_Road.prototype.destroyLastSegmentIsects = function() {
      var collision_polygon, i, isect, isect_obj, len, ref;
      ref = this.isects_last_segment;
      for (i = 0, len = ref.length; i < len; i++) {
        isect_obj = ref[i];
        if (isect_obj.type === 'p') {
          continue;
        }
        isect = isect_obj.isect;
        this.network.removeVisual(isect.getVisual());
        collision_polygon = isect.getCollisionPolygon();
        this.network.removeCollisionPolygon(collision_polygon);
      }
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.checkLegality = function() {
      var collision_polygon, query_box;
      collision_polygon = this.road.generateCollisionPolygon();
      return query_box = collision_polygon.generateBoundingBox();
    };

    I_Mouse_Build_Road.prototype.createTempIntersections = function() {
      var e_polyline, e_road, elem, elements, i, last_direction, last_point, len, p1, p2, polyline, query_box, query_polyline, temp_polyline, width;
      polyline = this.road.getCenterPolyline();
      temp_polyline = polyline.getLastSegment();
      query_box = temp_polyline.generateBoundingBox();
      elements = this.network.query_elements_box(query_box);
      for (i = 0, len = elements.length; i < len; i++) {
        elem = elements[i];
        if (elem instanceof TSAG.E_Road) {
          e_polyline = elem.getCenterPolyline();
          this._intersectPolygons(temp_polyline, e_polyline);
        }
      }
      last_point = temp_polyline.getLastPoint();
      last_direction = temp_polyline.getLastDirection();
      e_road = this._getRoadAtPt(last_point.x, last_point.y);
      if (e_road !== null) {
        e_polyline = e_road.getCenterPolyline();
        width = e_road.getWidth();
        p1 = last_point;
        p2 = last_point.add(last_direction.multScalar(width));
        query_polyline = new BDS.Polyline(false, [p1, p2]);
        this._intersectPolygons(query_polyline, e_polyline, e_road);
      }
    };

    I_Mouse_Build_Road.prototype._intersectPolygons = function(poly1, poly2, road_in_embedding) {
      var i, intersection, isect_pts, len, pt, results;
      isect_pts = poly1.report_intersections_with_polyline(poly2);
      results = [];
      for (i = 0, len = isect_pts.length; i < len; i++) {
        pt = isect_pts[i];
        intersection = new TSAG.E_Intersection(pt);
        this.isects_last_segment.push({
          isect: intersection,
          type: 's',
          road: road_in_embedding
        });
        this.network.addVisual(intersection.getVisual());
        results.push(this.network.addCollisionPolygon(intersection.getCollisionPolygon()));
      }
      return results;

      /*
       * Add intersections every time the mouse cursor intersects an older road.
      road_model = @network.query_road(event.x, event.y)
      if road_model != null
          @network.newIntersection(road_model.getPosition())
       */
    };

    I_Mouse_Build_Road.prototype._getIsectOrRoadAtPt = function(x, y) {
      var elem, elems, i, j, len, len1;
      elems = this.network.query_elements_pt(x, y);
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Intersection) {
          return elem;
        }
      }
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    I_Mouse_Build_Road.prototype._getRoadAtPt = function(x, y) {
      var elem, elems, i, len;
      elems = this.network.query_elements_pt(x, y);
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Highlight = (function() {
    function I_Mouse_Highlight(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.network = this.e_scene.getNetwork();
      this.previous_elements = [];
    }

    I_Mouse_Highlight.prototype.isIdle = function() {
      return true;
    };

    I_Mouse_Highlight.prototype.finish = function() {
      var prev_elem, results;
      results = [];
      while (this.previous_elements.length > 0) {
        prev_elem = this.previous_elements.pop();
        results.push(prev_elem.revertFillColor());
      }
      return results;
    };

    I_Mouse_Highlight.prototype.mouse_down = function(event) {
      if (this.previous_elements.length > 0) {

        /*
        @network.removeVisual(@previous_element.getVisual())
        @network.removeCollisionPolygon(@previous_element.getCollisionPolygon())
        #@network.removeTopology
         */
      }
    };

    I_Mouse_Highlight.prototype.mouse_up = function(event) {};

    I_Mouse_Highlight.prototype.mouse_move = function(event) {
      var elem, elems, i, len, results, road;
      this.finish();
      elems = this.network.query_elements_pt(event.x, event.y);
      results = [];
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Road) {
          road = elem;
          road.setFillColor(TSAG.style.highlight);
          results.push(this.previous_elements.push(road));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return I_Mouse_Highlight;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Interface = (function() {
    function I_Mouse_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Mouse_Interface.prototype.mouse_down = function(event) {};

    I_Mouse_Interface.prototype.mouse_up = function(event) {};

    I_Mouse_Interface.prototype.mouse_move = function(event) {};

    I_Mouse_Interface.prototype.isIdle = function() {};

    I_Mouse_Interface.prototype.finish = function() {};

    return I_Mouse_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Main = (function() {
    function I_Mouse_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.create_cursor();
      this.road_build_controller = new TSAG.I_Mouse_Build_Road(this.scene, this.camera);
      this.highlight_controller = new TSAG.I_Mouse_Highlight(this.scene, this.camera);
      this._current_mouse_input_controller = this.highlight_controller;
      this.state = "idle";
      this._min_dist = 10;
    }

    I_Mouse_Main.prototype.create_cursor = function() {
      var h, mesh, mesh_factory, params, scale, w;
      mesh_factory = new TSAG.Unit_Meshes();
      params = {
        color: TSAG.style.cursor_circle_color
      };
      mesh = mesh_factory.newCircle(params);
      scale = TSAG.style.cursor_circle_radius;
      mesh.position.z = TSAG.style.cursor_circle_z;
      w = scale;
      h = scale;
      scale = mesh.scale;
      scale.x = w;
      scale.y = h;
      this.scene.addOverlayVisual(mesh);
      return this.pointer = mesh;
    };

    I_Mouse_Main.prototype.mouse_down = function(event) {
      if (this._current_mouse_input_controller !== this.road_build_controller && this._current_mouse_input_controller.isIdle()) {
        this.switchController(this.road_build_controller);
      }
      return this._current_mouse_input_controller.mouse_down(event);
    };

    I_Mouse_Main.prototype.mouse_up = function(event) {
      return this._current_mouse_input_controller.mouse_up(event);
    };

    I_Mouse_Main.prototype.mouse_move = function(event) {
      var pos;
      if (this._current_mouse_input_controller !== this.highlight_controller && this._current_mouse_input_controller.isIdle()) {
        this.switchController(this.highlight_controller);
      }
      pos = this.pointer.position;
      pos.x = event.x;
      pos.y = event.y;
      return this._current_mouse_input_controller.mouse_move(event);
    };

    I_Mouse_Main.prototype.switchController = function(controller) {
      this._current_mouse_input_controller.finish();
      return this._current_mouse_input_controller = controller;
    };

    return I_Mouse_Main;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Building Rotation Time Controller.

Written by Bryce Summmers on 1 - 31 - 2017.

 - A Test time controller that takes every building in the scene and rotates it by a steady rate.
 */

(function() {
  TSAG.I_Time_Generate_Cars = (function() {
    function I_Time_Generate_Cars(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.time_count = 0.0;
      this.time_step = 1000.0;
    }

    I_Time_Generate_Cars.prototype.time = function(dt) {
      var car, destroyed, i, j, k, lane, lanes, len, len1, len2, network, road, roads, x, y;
      this.time_count += dt;
      this.gen_cars = false;
      if (this.time_count > this.time_step) {
        this.time_count = (this.time_count % this.time_step) - this.time_step;
        this.gen_cars = true;
      }
      network = this.scene.getNetwork();
      roads = network.getRoads();
      for (i = 0, len = roads.length; i < len; i++) {
        road = roads[i];
        lanes = road.getLanes();
        for (j = 0, len1 = lanes.length; j < len1; j++) {
          lane = lanes[j];
          if (this.gen_cars) {
            x = TSAG.style.road_offset_amount;
            y = TSAG.style.road_offset_amount;
            car = new TSAG.E_Car(new THREE.Vector3(x, y, 1));
            this.scene.addVisual(car.getVisual());
            lane.addCar(car);
          }
          destroyed = lane.moveCars();
          for (k = 0, len2 = destroyed.length; k < len2; k++) {
            car = destroyed[k];
            this.scene.removeVisual(car.getVisual());
          }
        }
      }
    };

    return I_Time_Generate_Cars;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Time Input Controller.

Written by Bryce Summmers on 1 - 31 - 2017.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Main = (function(superClass) {
    extend(I_Time_Main, superClass);

    function I_Time_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Main.__super__.constructor.call(this);
      this.add_time_input_controller(new TSAG.I_Time_Generate_Cars(this.scene, this.camera));
    }

    return I_Time_Main;

  })(TSAG.Input_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Building Rotation Time Controller.

Written by Bryce Summmers on 1 - 31 - 2017.

 - A Test time controller that takes every building in the scene and rotates it by a steady rate.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Rotate_Buildings = (function(superClass) {
    extend(I_Time_Rotate_Buildings, superClass);

    function I_Time_Rotate_Buildings(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Rotate_Buildings.__super__.constructor.call(this);
    }

    I_Time_Rotate_Buildings.prototype.time = function(dt) {
      var buildings, element, i, len, results;
      buildings = this.scene.getBuildings();
      results = [];
      for (i = 0, len = buildings.length; i < len; i++) {
        element = buildings[i];
        results.push(element.rotateBuilding(.01));
      }
      return results;
    };

    return I_Time_Rotate_Buildings;

  })(TSAG.Input_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      var material;
      this.outline_geometry = outline_geometry;
      material = TSAG.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, material);
      this.line_material = TSAG.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new TSAG.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (!(params.color instanceof THREE.Color)) {
        debugger;
      }
      mesh.material.color = params.color;
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new TSAG.Mesh_Unit_Square();
      this._circle = new TSAG.Mesh_Unit_Circle();
      this._triangle = new TSAG.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * GUI Set.
 *
 * This class may someday use AABB's to optimize clicks and handling of GUI button elements.
 *
 */

(function() {


}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_AABVH = (function() {
    function S_AABVH(obj, xyz) {
      var i, j, left_partition, ref, ref1, right_partition, triangle_list;
      this._leafs = [];
      this._leaf_node = false;
      if (obj instanceof THREE.Object3D) {
        triangle_list = this._extract_triangle_list(obj);
      } else {
        triangle_list = obj;
      }
      this._ensure_bounding_boxes(triangle_list);
      this._AABB = this._compute_AABB(triangle_list);
      if (triangle_list.length < 100) {
        this._leaf_node = true;
        for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangle_list[i]);
        }
        return;
      }
      if (xyz.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      triangle_list = this._sort_triangle_list(triangle_list, xyz);
      ref1 = this._partition_by_SA(triangle_list), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new TSAG.S_AABVH(left_partition, xyz);
      this._right = new TSAG.S_AABVH(right_partition, xyz);
    }

    S_AABVH.prototype.query_point = function(x, y) {
      var ray;
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    S_AABVH.prototype.query_ray = function(ray) {
      var a, b, c, i, intersection, j, output, ref, triangle;
      if (ray.intersectsBox(this._AABB) === null) {
        return null;
      }
      if (this._leaf_node) {
        for (i = j = 0, ref = this._leafs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangle = this._leafs[i];
          a = triangle.a;
          b = triangle.b;
          c = triangle.c;
          intersection = ray.intersectTriangle(a, b, c, false);
          if (intersection !== null) {
            return triangle;
          }
        }
      } else {
        output = this._left.query_ray(ray);
        if (output !== null) {
          return output;
        }
        output = this._right.query_ray(ray);
        if (output !== null) {
          return output;
        }
      }
      return null;
    };

    S_AABVH.prototype.toVisual = function(material) {
      var geom, geometries, j, len1, line, output;
      geometries = [];
      this.get_AABB_geometries(geometries);
      output = new THREE.Object3D();
      for (j = 0, len1 = geometries.length; j < len1; j++) {
        geom = geometries[j];
        line = new THREE.Line(geom, material);
        output.add(line);
      }
      return output;
    };

    S_AABVH.prototype.get_AABB_geometries = function(output) {
      var geometry, max, max_x, max_y, min, min_x, min_y;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(min_x, min_y, 0), new THREE.Vector3(max_x, min_y, 0), new THREE.Vector3(max_x, max_y, 0), new THREE.Vector3(min_x, max_y, 0), new THREE.Vector3(min_x, min_y, 0));
      output.push(geometry);
      if (!this._leaf_node) {
        this._left.get_AABB_geometries(output);
        this._right.get_AABB_geometries(output);
      }
    };


    /*
     - Private Construction Methods. -----------------------
     */

    S_AABVH.prototype._extract_triangle_list = function(obj) {
      var a, b, c, face, faces, geometry, j, k, len1, len2, localToWorld, mesh, mesh_list, triangle, triangle_list, vertices;
      mesh_list = this._extract_mesh_list(obj);
      triangle_list = [];
      for (j = 0, len1 = mesh_list.length; j < len1; j++) {
        mesh = mesh_list[j];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (k = 0, len2 = faces.length; k < len2; k++) {
          face = faces[k];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          triangle = new THREE.Triangle(a, b, c);
          triangle.mesh = mesh;
          triangle_list.push(triangle);
        }
      }
      return triangle_list;
    };

    S_AABVH.prototype._extract_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    S_AABVH.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    S_AABVH.prototype._nextXYZ = function(xyz) {
      if (xyz.dim === 2) {
        switch (xyz.val) {
          case 'x':
            return 'y';
          case 'y':
            return 'x';
          case 'z':
            console.log("xyz is malformed.");
        }
        debugger;
        console.log("xyz is malformed.");
      } else if (xyz.dim === 3) {
        switch (xyz) {
          case 'x':
            return 'y';
          case 'y':
            return 'z';
          case 'z':
            return 'x';
        }
      }
      debugger;
      return console.log("Case not handled.");
    };

    S_AABVH.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    S_AABVH.prototype._computeCentroid = function(triangle) {
      var centroid;
      centroid = new THREE.Vector3(0, 0, 0);
      centroid.add(triangle.a);
      centroid.add(triangle.b);
      centroid.add(triangle.c);
      centroid.divideScalar(3);
      return centroid;
    };

    S_AABVH.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    S_AABVH.prototype._ensure_bounding_boxes = function(triangle_list) {
      var i, j, len, ref, results, triangle;
      len = triangle_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        if (!triangle) {
          debugger;
        }
        if (!triangle.boundingBox) {
          results.push(this._computeBoundingBox(triangle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    S_AABVH.prototype._computeBoundingBox = function(triangle) {
      var AABB;
      AABB = new THREE.Box3();
      AABB.expandByPoint(triangle.a);
      AABB.expandByPoint(triangle.b);
      AABB.expandByPoint(triangle.c);
      return triangle.boundingBox = AABB;
    };

    S_AABVH.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new THREE.Box3();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.boundingBox;
        output.union(AABB);
      }
      return output;
    };

    S_AABVH.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    return S_AABVH;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len = vecs.length; j < len; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
      this._cumulative_lengths = [];
      this._unit_tangents = [];
      this._total_length = 0;
    }

    S_Curve.prototype.addPoint = function(p) {
      this._spline.addPoint(this.vec_to_point(p));
      this._total_length += this._spline.getLastSegmentDistance();
      this._cumulative_lengths.push(this._total_length);
      if (this.numPoints() > 1) {
        this._unit_tangents.push(this._spline.getLastSegmentDirection());
      }
    };

    S_Curve.prototype.numPoints = function() {
      return this._spline.size();
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this.point_to_vec(this._spline.getPoint(i));
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.point_to_vec(this._spline.getLastPoint());
    };

    S_Curve.prototype.removeLastPoint = function() {
      this._total_length -= this._spline.getLastSegmentDistance();
      this._cumulative_lengths.pop();
      this._unit_tangents.pop();
      return this._spline.removeLastPoint();
    };

    S_Curve.prototype.position = function(t) {
      var dir, distance, distance_to_go, i1, i2, p1, p2, start_distance;
      i1 = this._get_segment_start_index(t);
      if (i1 >= this.numPoints() - 1) {
        return this.getLastPoint();
      }
      i2 = i1 + 1;
      distance = t * this._total_length;
      start_distance = this._cumulative_lengths[i1];
      distance_to_go = distance - start_distance;
      p1 = this._spline.getPoint(i1);
      p2 = this._spline.getPoint(i2);
      dir = p1.directionTo(p2);
      return this.point_to_vec(p1.add(dir.multScalar(distance_to_go)));
    };

    S_Curve.prototype.tangent = function(t) {
      var index;
      index = this._get_segment_start_index(t);
      if (index >= this._unit_tangents.length) {
        index--;
      }
      return this.point_to_vec(this._unit_tangents[index]);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype._get_segment_start_index = function(t) {
      var distance;
      distance = t * this._total_length;
      return BDS.Arrays.binarySearch(this._cumulative_lengths, distance);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var index, j, len, ref, vec;
      this._discretization = [];
      len = this.numPoints();
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        vec = this.getPointAtIndex(index);
        this._discretization.push(vec);
      }
      return this._discretization;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var distance, j, len, len1, out, ref, time;
      out = [];
      len = 0;
      ref = this._cumulative_lengths;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        distance = ref[j];
        time = distance / this._total_length;
        times_output.push(time);
        out.push(this.offset(time, amount));
      }
      return out;
    };


    /*
    updateDiscretization: (max_length) ->
        output = []
        p0 = @position(0)
        output.push(p0)
    
        S = [] # Stack.
        S.push(1.0)
        
        low   = 0
        p_low = @position(low)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval
         * every time an interval is less than the max_length, subdivision is terminated.
    
         * Left to right subdivision loop. Performs a binary search across all intervals.
        while S.length != 0
        
            high   = S.pop()
            p_high = @position(high)
        
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high   = (low + high)/2.0
                p_high = @position(high)
        
            output.push(p_high)
            low   = high
            p_low = p_high
            continue
    
        @_discretization = output
    
     * max_length:float, maximum length out output segment.
     * amount: the distance the offset curve is away from the main curve. positive or negative is fine.
     * time_output (optional) will be populated with the times for the output points.
     * ASSUMPTION: this function assumes that it is sampling from continuously defined offsets.
    getOffsets: (max_length, amount, times_output) ->
    
        o0 = @offset(0, amount)
        output = []
        output.push(o0)
        times_output.push(0) if times_output
    
        S = []; # Stack.
        S.push(1.0)
        low = 0
        p_low = @offset(low, amount)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval.
         * every time an interval is terminated after subdivision is sufficient.
    
         * Left to right subdivision loop.
        while S.length != 0
        
            high   = S.pop()
            p_high = @offset(high, amount)
    
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
            
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high = (low + high)/2.0
                p_high = @offset(high, amount)
            
    
            output.push(p_high)
            times_output.push(high) if times_output
            low = high
            p_low = p_high
            continue
        
        return output
     */

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len1, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len1 = vecs.length; j < len1; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    S_Curve.prototype.vec_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y);
    };

    S_Curve.prototype.point_to_vec = function(pt) {
      return new THREE.Vector3(pt.x, pt.y);
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Vertex = (function() {
    function S_Vertex() {
      this._edges = [];
      this._element = null;
    }

    S_Vertex.prototype.addEdge = function(edge) {
      return this._edges.push(edge);
    };

    S_Vertex.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Vertex.prototype.getElement = function() {
      return this._element;
    };

    return S_Vertex;

  })();

  TSAG.S_Edge = (function() {
    function S_Edge() {
      this._v0 = null;
      this._v1 = null;
      this.element = null;
    }

    S_Edge.prototype.getStartVert = function() {
      return this._v0;
    };

    S_Edge.prototype.getEndVert = function() {
      return this._v1;
    };

    S_Edge.prototype.setStartVert = function(v0) {
      return this._v0 = v0;
    };

    S_Edge.prototype.setEndVert = function(v1) {
      return this._v1 = v1;
    };

    S_Edge.prototype.setVerts = function(v0, v1) {
      this._v0 = v0;
      return this._v1 = v1;
    };

    S_Edge.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Edge.prototype.getElement = function() {
      return this._element;
    };

    return S_Edge;

  })();

  TSAG.S_Network_Topology = (function() {
    function S_Network_Topology() {
      this._bvh_needs_update = true;
      this._bvh = null;
      this._vertices = [];
      this._edges = [];
    }

    S_Network_Topology.prototype.newVertex = function() {
      var vert;
      vert = new TSAG.S_Vertex();
      this._vertices.push(vert);
      return vert;
    };

    S_Network_Topology.prototype.newEdge = function() {
      var edge;
      edge = new TSAG.S_Edge();
      this._edges.push(edge);
      return edge;
    };

    return S_Network_Topology;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  TSAG.init_style = function() {
    TSAG.style = {
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_car_fill: new THREE.Color(0x00aaaa),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0,
      dz_cars: .02,
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000)
    };
    return TSAG.style.unit_meshes = new TSAG.Unit_Meshes();
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers on 12 - 16 - 2016.
 */


/*
 * Testing Axis Aligned Bounding Box.
 */

(function() {
  TSAG.Testing = (function() {
    function Testing() {}

    Testing.prototype.test_AABB = function() {
      var AABB, direction, geometry, i, inter, mesh, origin, ray, ref, scene, x, y;
      scene = new THREE.Scene();
      geometry = new THREE.Geometry();
      y = 0;
      for (x = i = 0; i <= 10; x = ++i) {
        mesh = this.test_mesh(new THREE.Vector3(x * 3 + 0, y * 3 + 1, 0), new THREE.Vector3(x * 3 + -1, y * 3 - 1, 0), new THREE.Vector3(x * 3 + 1, y * 3 - 1, 0));
        scene.add(mesh);
      }
      AABB = new TSAG.AABB(scene, {
        val: 'x',
        dim: 2
      });
      origin = new THREE.Vector3(0, 0, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      ref = AABB.collision_query(ray), mesh = ref[0], inter = ref[1];
      console.log(mesh);
      return console.log(inter);
    };

    Testing.prototype.test_mesh = function(a, b, c) {
      var geometry, material, mesh;
      geometry = new THREE.Geometry();
      geometry.vertices.push(a, b, c);
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      material = new THREE.MeshBasicMaterial({
        color: 0xffff00
      });
      return mesh = new THREE.Mesh(geometry, material);
    };

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Scribble.JS Halfedge Graph data classes.
    Data Classes that associated Sim Urban relevant information with Halfedge graph Topology members.

    Written by Bryce Summers on 3 - 7 - 2017.
 */

(function() {
  TSAG.Graph_Data = (function() {
    function Graph_Data(graph) {
      this.graph = graph;
    }

    Graph_Data.prototype.clearFaceMarks = function() {
      var iter, results;
      iter = this.graph.facesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearVertexMarks = function() {
      var iter, results;
      iter = this.graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearEdgeMarks = function() {
      var iter, results;
      iter = this.graph.edgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearHalfedgeMarks = function() {
      var iter, results;
      iter = this.graph.halfedgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearMarks = function() {
      this.clearFaceMarks();
      this.clearVertexMarks();
      this.clearEdgeMarks();
      return this.clearHalfedgeMarks();
    };

    return Graph_Data;

  })();

  TSAG.Face_Data = (function() {
    function Face_Data(face) {
      this.face = face;
      this.marked = false;
      this.element = null;
    }

    return Face_Data;

  })();

  TSAG.Vertex_Data = (function() {
    function Vertex_Data(vertex) {
      this.vertex = vertex;
      this.marked = false;
      this.point = null;
      this.element = null;
    }

    return Vertex_Data;

  })();

  TSAG.Edge_Data = (function() {
    function Edge_Data(edge) {
      this.edge = edge;
      this.marked = false;
      this.element = null;
    }

    return Edge_Data;

  })();

  TSAG.Halfedge_Data = (function() {
    function Halfedge_Data(halfedge) {
      this.halfedge = halfedge;
      this.marked = false;
      this.next_extraordinary = null;
      this.element = null;

      /*
      @_curve
      @_time1
      @_time2
       */
    }


    /*
    
    I wonder if these will be useful in Sim Urban???
    
     * Halfedges may represent subsections of curves.
    setAssociatedCurve: (obj) ->
        @_curve = obj
        return
    
    getAssociatedCurve: () ->
        return @_curve
    
     * Associate parameter values with the beginning and end of this halfedge.
    setTimes: (time1, time2) ->
        @_time1 = time1
        @_time2 = time2
    
    getTimes: () ->
        return undefined if @_time1 is undefined
        return [@_time1, @_time2]
     */

    return Halfedge_Data;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Sim Urban Topology Linked Element Generator.

Written by Bryce Summers on 3 - 7 - 2017.

Purpose
 */


/*

Polyline Graph Topology Generator.

Generates Halfedge Topology associated with Polyline Graph Data Objects.

Written by Bryce Summers
Move to its own file on 3 - 7 - 2017.
 */

(function() {
  TSAG.PolylineGraphGenerator = (function() {
    function PolylineGraphGenerator(_graph) {
      var new_edges, new_faces, new_halfedges, new_vertices;
      this._graph = _graph;
      new_faces = [];
      new_edges = [];
      new_halfedges = [];
      new_vertices = [];
    }

    PolylineGraphGenerator.prototype.allocateGraph = function() {
      this._graph = this.newGraph();
      return this._graph;
    };

    PolylineGraphGenerator.prototype.newGraph = function() {
      var output;
      output = new SCRIB.Graph(false);
      output.data = new TSAG.Graph_Data(output);
      return output;
    };

    PolylineGraphGenerator.prototype.newFace = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newFace();
      output.data = new TSAG.Face_Data(output);
      this.new_faces.push(output);
      return output;
    };

    PolylineGraphGenerator.prototype.newEdge = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newEdge();
      output.data = new TSAG.Edge_Data(output);
      this.new_edges.push(output);
      return output;
    };

    PolylineGraphGenerator.prototype.newHalfedge = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newHalfedge();
      output.data = new TSAG.Halfedge_Data(output);
      this.new_halfedges.push(output);
      return output;
    };

    PolylineGraphGenerator.prototype.newVertex = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newVertex();
      output.data = new TSAG.Vertex_Data(output);
      this.new_vertices.push(output);
      return output;
    };

    PolylineGraphGenerator.prototype.flushNewFaces = function() {
      var output;
      output = this.new_faces;
      this.new_faces = [];
      return output;
    };

    PolylineGraphGenerator.prototype.flushNewEdges = function() {
      var output;
      output = this.new_edges;
      this.new_edges = [];
      return output;
    };

    PolylineGraphGenerator.prototype.flushNewHalfedges = function() {
      var output;
      output = this.new_halfedges;
      this.new_halfedges = [];
      return output;
    };

    PolylineGraphGenerator.prototype.flushNewVertices = function() {
      var output;
      output = this.new_vertices;
      this.new_vertices = [];
      return output;
    };

    PolylineGraphGenerator.prototype.line_side_test = function(vert1, vert2, vert3) {
      var pt_c, ray;
      pt_c = vert3.data.point;
      ray = this._ray(vert1, vert2);
      return ray.line_side_test(pt_c);
    };

    PolylineGraphGenerator.prototype.vert_in_angle = function(vert_a, vert_b, vert_c, vert_pt) {
      var angle1, angle2, angle_pt, ray1, ray2, ray_pt;
      ray1 = this._ray(vert_b, vert_c);
      ray2 = this._ray(vert_b, vert_a);
      ray_pt = this._ray(vert_b, vert_pt);
      angle1 = ray1.getAngle();
      angle2 = ray2.getAngle();
      angle_pt = ray_pt.getAngle();
      if (angle2 <= angle1) {
        angle2 += Math.PI * 2;
      }
      if (angle_pt < angle1) {
        angle_pt += Math.PI * 2;
      }
      return angle1 <= angle_pt && angle_pt <= angle2;
    };

    PolylineGraphGenerator.prototype._ray = function(v1, v2) {
      var a, b, dir, ray;
      a = v1.data.point;
      b = v2.data.point;
      dir = b.sub(a);
      ray = new BDS.Ray(a, dir, 1);
      return ray;
    };

    return PolylineGraphGenerator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Math = {};

  TSAG.Math.distance = function(x1, y1, x2, y2) {
    return Math.sqrt(TSAG.Math.distance_sqr(x1, y1, x2, y2));
  };

  TSAG.Math.distance_sqr = function(x1, y1, x2, y2) {
    var dx, dy;
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.M_Road = (function() {
    function M_Road(t0, t11, road) {
      this.t0 = t0;
      this.t1 = t11;
      this.road = road;
    }

    M_Road.prototype.getPosition = function() {
      return this.road.getPosition((this.t0 + t1) / 2);
    };

    return M_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(.5, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Square;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(TSAG.Mesh_Basic);

}).call(this);

/*
 * Entry Point to my Transportation Simulation Game.
 * Sets up THREE.js on the DOM and sets up input from the browser.
 * Written by Bryce Summers on 11/22/2016
 */

var renderer;
var root_e_scene;
var root_camera;

var input;
var root_AABB;

function init()
{
    // run some Tests.
    new TSAG.Testing();

    // Initialize all of the global material, mesh constructor's, etc.
    TSAG.init_style();

    // Scene Graph.
    root_e_scene = new TSAG.E_Scene(window.innerWidth, window.innerHeight);

    // Camera.
    var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 2;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))


    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Clear to white Background.
    // FIXME: Use a Style Class.
    // FIXME: Move this to a background prropery of the E_Scene.
    renderer.setClearColor( 0xD8C49E );

    init_input();
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( window.devicePixelRatio );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    // Initialize the root of the input specification tree.
    input = new TSAG.I_All_Main(root_e_scene, root_camera);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);

    // The current system time, used to correctly pass time deltas.
    TIMESTAMP = performance.now();

    // Initialize Time input.
    beginTime();

    TIME_ON = true;
}

function beginTime()
{
    TIMESTAMP = performance.now();
    TIME_ON   = true;
    timestep();
}

function timestep()
{
    if(TIME_ON)
    {
        requestAnimationFrame(timestep)
    }
    else
    {
        return;
    }

    time_new = performance.now()
    var dt = time_new - TIMESTAMP
    TIMESTAMP = time_new

    try
    {
        input.time(dt)
    }
    catch(err)
    { // Stop time on error.
        TIME_ON = false
        throw err
    }

}

// Events.
function onWindowResize( event )
{
    renderer.setSize( window.innerWidth, window.innerHeight );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
}

function onMouseMove( event )
{
    input.mouse_move(event);
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    if(isRightMB)
        return

    input.mouse_down(e);
}

function onMouseUp( event )
{
    input.mouse_up(event);
}

function animate()
{
    requestAnimationFrame( animate );
    render();
}

function render()
{
    renderer.render(root_e_scene.getVisual(), root_camera);
}

init();
animate();