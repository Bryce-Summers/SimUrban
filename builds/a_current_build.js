/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 20-12-2016
 */
/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
TSAG = {};

// Generated by CoffeeScript 1.11.1

/*
 *
 * Element Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  TSAG.E_Super = (function() {
    function E_Super(_view) {
      this._view = _view;
      if (!this._view) {
        this._view = new THREE.Object3D();
      }
      this._BVH = null;
    }

    E_Super.prototype.getVisual = function() {
      return this._view;
    };

    return E_Super;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Building Element Class.
 * 
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Purpose: This class specifies the gameplay andd aesthetic properties of building objects.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Building = (function(superClass) {
    extend(E_Building, superClass);

    function E_Building(position, scale, rotation_z) {
      var _position, _rz, mesh, view;
      E_Building.__super__.constructor.call(this);
      view = this.getVisual();
      _position = position;
      _rz = rotation_z;
      mesh = this._newHouse({
        color: TSAG.style.c_building_fill
      });
      mesh.position.copy(position.clone());
      mesh.scale.copy(scale.clone());
      mesh.rotation.z = rotation_z;
      view.add(mesh);
    }

    E_Building.prototype._newHouse = function(params) {
      var mesh_factory, node, square, triangle;
      mesh_factory = TSAG.style.unit_meshes;
      square = mesh_factory.newSquare(params);
      triangle = mesh_factory.newTriangle(params);
      triangle.position.x = .5;
      triangle.scale.x = .5;
      node = new THREE.Object3D();
      node.add(square);
      node.add(triangle);
      return node;
    };

    return E_Building;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Intersection = (function(superClass) {
    extend(E_Intersection, superClass);

    function E_Intersection(s_vertex, position) {
      var fill, sx, sy, view;
      E_Intersection.__super__.constructor.call(this);
      this._vertex = s_vertex;
      this._position = position;
      fill = TSAG.style.unit_meshes.newSquare({
        color: TSAG.style.c_road_fill
      });
      fill.position.copy(this._position.clone());
      sx = sy = TSAG.style.road_offset_amount * 2;
      fill.scale.copy(new THREE.Vector3(sx, sy, 1));
      view = this.getVisual();
      view.add(fill);
      view.position.z = TSAG.style.dz_intersection;
    }

    E_Intersection.prototype.addRoad = function(road) {
      var edge;
      edge = road.getEdge();
      this._vertex.addEdge(edge);
      return true;
    };

    E_Intersection.prototype.getVertex = function() {
      return this._vertex;
    };

    return E_Intersection;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Network = (function(superClass) {
    extend(E_Network, superClass);

    function E_Network() {
      E_Network.__super__.constructor.call(this);
      this._bvh_needs_update = true;
      this._bvh = null;
      this._network_topology = new TSAG.S_Network_Topology();
      this._intersections = [];
      this._roads = [];
    }

    E_Network.prototype.newRoad = function(x, y) {
      var edge, intersection, road, vertex, visual;
      this._BVH = new TSAG.S_AABVH(this.getVisual(), {
        val: 'x',
        dim: 2
      });
      intersection = this.newIntersection(x, y);
      vertex = intersection.getVertex();
      edge = this._network_topology.newEdge();
      edge.setStartVert(vertex);
      road = new TSAG.E_Road(edge);
      edge.setElement(road);
      this._roads.push(road);
      visual = this.getVisual();
      visual.add(road.getVisual());
      return road;
    };

    E_Network.prototype.newIntersection = function(x, y) {
      var intersection, position, vertex, visual;
      this._BVH = new TSAG.S_AABVH(this.getVisual(), {
        val: 'x',
        dim: 2
      });
      vertex = this._network_topology.newVertex();
      position = new THREE.Vector3(x, y, 0);
      intersection = new TSAG.E_Intersection(vertex, position);
      vertex.setElement(intersection);
      this._intersections.push(intersection);
      visual = this.getVisual();
      visual.add(intersection.getVisual());
      return intersection;
    };

    E_Network.prototype.query_road = function(x, y) {
      var element, model, triangle;
      triangle = this._BVH.query_point(x, y);
      if (triangle === null) {
        return null;
      }
      triangle.mesh.material.color = new THREE.Color(Math.random(), Math.random(), Math.random());
      model = triangle.model;
      element = triangle.mesh.element;
      if (element instanceof TSAG.E_Intersection) {
        return null;
      }
      if (model instanceof TSAG.M_Road) {
        return model;
      }
      return null;
    };

    return E_Network;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Road = (function(superClass) {
    extend(E_Road, superClass);

    function E_Road(edge) {
      var visual;
      E_Road.__super__.constructor.call(this);
      this._edge = edge;
      this._main_curve = new TSAG.S_Curve();
      visual = this.getVisual();
      visual.position.z = TSAG.style.dz_road;
      this._road_visual = null;
    }

    E_Road.prototype.addPoint = function(pt) {
      this._main_curve.addPoint(pt);
      return true;
    };

    E_Road.prototype.removeLastPoint = function() {
      return this._main_curve.removeLastPoint();
    };

    E_Road.prototype.getPosition = function(time) {
      return this._main_curve.position(time);
    };

    E_Road.prototype.updateDiscretization = function(max_length) {
      var fill_geometry, fill_material, fill_mesh, left_line, material, middle_line, middle_material, offset_amount, right_line, times_left, times_right, verts_left, verts_right, visual;
      offset_amount = TSAG.style.road_offset_amount;
      this._main_curve.updateDiscretization(max_length);
      visual = this.getVisual();
      visual.remove(this._road_visual);
      this._road_visual = new THREE.Object3D();
      visual.add(this._road_visual);
      material = TSAG.style.m_default_line.clone();
      material.color = TSAG.style.c_road_outline;
      middle_material = TSAG.style.m_default_line.clone();
      middle_material.color = TSAG.style.c_road_midline;
      middle_line = new THREE.Geometry();
      middle_line.vertices = this._main_curve.getDiscretization();
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = this._main_curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = this._main_curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = TSAG.style.m_default_fill.clone();
      fill_material.color = TSAG.style.c_road_fill;
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      this._road_visual.add(fill_mesh);
      this._road_visual.add(new THREE.Line(middle_line, middle_material));
      this._road_visual.add(new THREE.Line(left_line, material));
      return this._road_visual.add(new THREE.Line(right_line, material));
    };

    E_Road.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    return E_Road;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban Scene Object.
    Written by Bryce on 11/22/2016
    Refactored by Bryce on 12 - 18 - 2016.
    
    Purpose: This class organizes all of the structural layers in the game.
        It serves as the root of the scene graph for all rendering.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Scene = (function(superClass) {
    extend(E_Scene, superClass);

    function E_Scene(scene_width, scene_height) {
      var building, h, i, j, pos, rz, scale, view, w, x, y;
      E_Scene.__super__.constructor.call(this, new THREE.Scene());
      view = this.getVisual();
      this._AABB = null;
      this._network = new TSAG.E_Network();
      view.add(this._network.getVisual());
      this._overlays = new THREE.Object3D();
      this._overlays.name = "Overlays";
      view.add(this._overlays);
      this._buildings = new THREE.Object3D();
      this._buildings.name = "Buildings";
      view.add(this._buildings);
      this._scale = 40;
      this._padding = 30;
      for (i = j = 0; j < 10; i = ++j) {
        x = this._padding + Math.random() * (scene_width - this._padding * 2);
        y = this._padding + Math.random() * (scene_height - this._padding * 2);
        w = this._scale;
        h = this._scale;
        rz = Math.random() * Math.PI * 2;
        pos = new THREE.Vector3(x, y, 0);
        scale = new THREE.Vector3(w, h, 1);
        building = new TSAG.E_Building(pos, scale, rz);
        this._buildings.add(building.getVisual());
      }
      return;
    }

    E_Scene.prototype.addOverlayVisual = function(obj) {
      return this._overlays.add(obj);
    };

    E_Scene.prototype.removeOverlayVisual = function(obj) {
      return this._overlays.remove(obj);
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.getMeshFactory = function() {
      return TSAG.style.unit_meshes;
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.queryPoint = function(x, y) {
      var direction, origin, ray, results;
      origin = new THREE.Vector3(x, y, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      results = this._AABB.collision_query(ray);
      return results;
    };

    return E_Scene;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_All_Main = (function() {
    function I_All_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this._mouse_input = new TSAG.I_Mouse_Main(this.scene, this.camera);
    }

    I_All_Main.prototype.mouse_down = function(event) {
      return this._mouse_input.mouse_down(event);
    };

    I_All_Main.prototype.mouse_up = function(event) {
      return this._mouse_input.mouse_up(event);
    };

    I_All_Main.prototype.mouse_move = function(event) {
      return this._mouse_input.mouse_move(event);
    };

    return I_All_Main;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.next_point = null;
    }

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, max_length, pos;
      if (this.state === "idle") {
        this.network = this.e_scene.getNetwork();
        this.road = this.network.newRoad(event.x, event.y);
        this.road.addPoint(new THREE.Vector3(event.x, event.y, 0));
        this.next_point = new THREE.Vector3(event.x, event.y + 1, 0);
        this.road.addPoint(this.next_point);
        this.state = "building";
        this._mousePrevious.x = event.x;
        return this._mousePrevious.y = event.y;
      } else {
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          this.next_point = new THREE.Vector3(event.x + .01, event.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          return this._mousePrevious.y = event.y;
        } else {
          this.road.removeLastPoint();
          this.state = "idle";
          max_length = TSAG.style.discretization_length;
          this.road.updateDiscretization(max_length);
          return this.road = null;
        }
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var max_length, road_model;
      if (this.state === "building") {
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        max_length = TSAG.style.discretization_length;
        this.road.updateDiscretization(max_length);
        road_model = this.network.query_road(event.x, event.y);
        if (road_model !== null) {
          return this.network.newIntersection(road_model.getPosition());
        }
      }
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Interface = (function() {
    function I_Mouse_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Mouse_Interface.prototype.mouse_down = function(event) {};

    I_Mouse_Interface.prototype.mouse_up = function(event) {};

    I_Mouse_Interface.prototype.mouse_move = function(event) {};

    return I_Mouse_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Main = (function() {
    function I_Mouse_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.create_cursor();
      this.road_build_controller = new TSAG.I_Mouse_Build_Road(this.scene, this.camera);
      this._current_mouse_input_controller = this.road_build_controller;
      this.state = "idle";
      this._min_dist = 10;
    }

    I_Mouse_Main.prototype.create_cursor = function() {
      var h, mesh, mesh_factory, params, scale, w;
      mesh_factory = new TSAG.Unit_Meshes();
      params = {
        color: TSAG.style.cursor_circle_color
      };
      mesh = mesh_factory.newCircle(params);
      scale = TSAG.style.cursor_circle_radius;
      mesh.position.z = TSAG.style.cursor_circle_z;
      w = scale;
      h = scale;
      scale = mesh.scale;
      scale.x = w;
      scale.y = h;
      this.scene.addOverlayVisual(mesh);
      return this.pointer = mesh;
    };

    I_Mouse_Main.prototype.mouse_down = function(event) {
      return this._current_mouse_input_controller.mouse_down(event);
    };

    I_Mouse_Main.prototype.mouse_up = function(event) {
      return this._current_mouse_input_controller.mouse_up(event);
    };

    I_Mouse_Main.prototype.mouse_move = function(event) {
      var pos;
      pos = this.pointer.position;
      pos.x = event.x;
      pos.y = event.y;
      return this._current_mouse_input_controller.mouse_move(event);
    };

    return I_Mouse_Main;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      var material;
      this.outline_geometry = outline_geometry;
      material = TSAG.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, material);
      this.line_material = TSAG.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new TSAG.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (!(params.color instanceof THREE.Color)) {
        debugger;
      }
      mesh.material.color = params.color;
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new TSAG.Mesh_Unit_Square();
      this._circle = new TSAG.Mesh_Unit_Circle();
      this._triangle = new TSAG.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * GUI Set.
 *
 * This class may someday use AABB's to optimize clicks and handling of GUI button elements.
 *
 */

(function() {


}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_AABVH = (function() {
    function S_AABVH(obj, xyz) {
      var i, j, left_partition, ref, ref1, right_partition, triangle_list;
      this._leafs = [];
      this._leaf_node = false;
      if (obj instanceof THREE.Object3D) {
        triangle_list = this._extract_triangle_list(obj);
      } else {
        triangle_list = obj;
      }
      this._ensure_bounding_boxes(triangle_list);
      this._AABB = this._compute_AABB(triangle_list);
      if (triangle_list.length < 100) {
        this._leaf_node = true;
        for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangle_list[i]);
        }
        return;
      }
      if (xyz.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      triangle_list = this._sort_triangle_list(triangle_list, xyz);
      ref1 = this._partition_by_SA(triangle_list), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new TSAG.S_AABVH(left_partition, xyz);
      this._right = new TSAG.S_AABVH(right_partition, xyz);
    }

    S_AABVH.prototype.query_point = function(x, y) {
      var ray;
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    S_AABVH.prototype.query_ray = function(ray) {
      var a, b, c, i, intersection, j, output, ref, triangle;
      if (ray.intersectsBox(this._AABB) === null) {
        return null;
      }
      if (this._leaf_node) {
        for (i = j = 0, ref = this._leafs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangle = this._leafs[i];
          a = triangle.a;
          b = triangle.b;
          c = triangle.c;
          intersection = ray.intersectTriangle(a, b, c, false);
          if (intersection !== null) {
            return triangle;
          }
        }
      } else {
        output = this._left.query_ray(ray);
        if (output !== null) {
          return output;
        }
        output = this._right.query_ray(ray);
        if (output !== null) {
          return output;
        }
      }
      return null;
    };

    S_AABVH.prototype.toVisual = function(material) {
      var geom, geometries, j, len1, line, output;
      geometries = [];
      this.get_AABB_geometries(geometries);
      output = new THREE.Object3D();
      for (j = 0, len1 = geometries.length; j < len1; j++) {
        geom = geometries[j];
        line = new THREE.Line(geom, material);
        output.add(line);
      }
      return output;
    };

    S_AABVH.prototype.get_AABB_geometries = function(output) {
      var geometry, max, max_x, max_y, min, min_x, min_y;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(min_x, min_y, 0), new THREE.Vector3(max_x, min_y, 0), new THREE.Vector3(max_x, max_y, 0), new THREE.Vector3(min_x, max_y, 0), new THREE.Vector3(min_x, min_y, 0));
      output.push(geometry);
      if (!this._leaf_node) {
        this._left.get_AABB_geometries(output);
        this._right.get_AABB_geometries(output);
      }
    };


    /*
     - Private Construction Methods. -----------------------
     */

    S_AABVH.prototype._extract_triangle_list = function(obj) {
      var a, b, c, face, faces, geometry, j, k, len1, len2, localToWorld, mesh, mesh_list, triangle, triangle_list, vertices;
      mesh_list = this._extract_mesh_list(obj);
      triangle_list = [];
      for (j = 0, len1 = mesh_list.length; j < len1; j++) {
        mesh = mesh_list[j];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (k = 0, len2 = faces.length; k < len2; k++) {
          face = faces[k];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          triangle = new THREE.Triangle(a, b, c);
          triangle.mesh = mesh;
          triangle_list.push(triangle);
        }
      }
      return triangle_list;
    };

    S_AABVH.prototype._extract_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    S_AABVH.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    S_AABVH.prototype._nextXYZ = function(xyz) {
      if (xyz.dim === 2) {
        switch (xyz.val) {
          case 'x':
            return 'y';
          case 'y':
            return 'x';
          case 'z':
            console.log("xyz is malformed.");
        }
        debugger;
        console.log("xyz is malformed.");
      } else if (xyz.dim === 3) {
        switch (xyz) {
          case 'x':
            return 'y';
          case 'y':
            return 'z';
          case 'z':
            return 'x';
        }
      }
      debugger;
      return console.log("Case not handled.");
    };

    S_AABVH.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    S_AABVH.prototype._computeCentroid = function(triangle) {
      var centroid;
      centroid = new THREE.Vector3(0, 0, 0);
      centroid.add(triangle.a);
      centroid.add(triangle.b);
      centroid.add(triangle.c);
      centroid.divideScalar(3);
      return centroid;
    };

    S_AABVH.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    S_AABVH.prototype._ensure_bounding_boxes = function(triangle_list) {
      var i, j, len, ref, results, triangle;
      len = triangle_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        if (!triangle) {
          debugger;
        }
        if (!triangle.boundingBox) {
          results.push(this._computeBoundingBox(triangle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    S_AABVH.prototype._computeBoundingBox = function(triangle) {
      var AABB;
      AABB = new THREE.Box3();
      AABB.expandByPoint(triangle.a);
      AABB.expandByPoint(triangle.b);
      AABB.expandByPoint(triangle.c);
      return triangle.boundingBox = AABB;
    };

    S_AABVH.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new THREE.Box3();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.boundingBox;
        output.union(AABB);
      }
      return output;
    };

    S_AABVH.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    return S_AABVH;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Vertex = (function() {
    function S_Vertex() {
      this._edges = [];
      this._element = null;
    }

    S_Vertex.prototype.addEdge = function(edge) {
      return this._edges.push(edge);
    };

    S_Vertex.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Vertex.prototype.getElement = function() {
      return this._element;
    };

    return S_Vertex;

  })();

  TSAG.S_Edge = (function() {
    function S_Edge() {
      this._v0 = null;
      this._v1 = null;
      this.element = null;
    }

    S_Edge.prototype.getStartVert = function() {
      return this._v0;
    };

    S_Edge.prototype.getEndVert = function() {
      return this._v1;
    };

    S_Edge.prototype.setStartVert = function(v0) {
      return this._v0 = v0;
    };

    S_Edge.prototype.setEndVert = function(v1) {
      return this._v1 = v1;
    };

    S_Edge.prototype.setVerts = function(v0, v1) {
      this._v0 = v0;
      return this._v1 = v1;
    };

    S_Edge.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Edge.prototype.getElement = function() {
      return this._element;
    };

    return S_Edge;

  })();

  TSAG.S_Network_Topology = (function() {
    function S_Network_Topology() {
      this._bvh_needs_update = true;
      this._bvh = null;
      this._vertices = [];
      this._edges = [];
    }

    S_Network_Topology.prototype.newVertex = function() {
      var vert;
      vert = new TSAG.S_Vertex();
      this._vertices.push(vert);
      return vert;
    };

    S_Network_Topology.prototype.newEdge = function() {
      var edge;
      edge = new TSAG.S_Edge();
      this._edges.push(edge);
      return edge;
    };

    return S_Network_Topology;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  TSAG.init_style = function() {
    TSAG.style = {
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0
    };
    return TSAG.style.unit_meshes = new TSAG.Unit_Meshes();
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers on 12 - 16 - 2016.
 */


/*
 * Testing Axis Aligned Bounding Box.
 */

(function() {
  TSAG.Testing = (function() {
    function Testing() {}

    Testing.prototype.test_AABB = function() {
      var AABB, direction, geometry, i, inter, mesh, origin, ray, ref, scene, x, y;
      scene = new THREE.Scene();
      geometry = new THREE.Geometry();
      y = 0;
      for (x = i = 0; i <= 10; x = ++i) {
        mesh = this.test_mesh(new THREE.Vector3(x * 3 + 0, y * 3 + 1, 0), new THREE.Vector3(x * 3 + -1, y * 3 - 1, 0), new THREE.Vector3(x * 3 + 1, y * 3 - 1, 0));
        scene.add(mesh);
      }
      AABB = new TSAG.AABB(scene, {
        val: 'x',
        dim: 2
      });
      origin = new THREE.Vector3(0, 0, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      ref = AABB.collision_query(ray), mesh = ref[0], inter = ref[1];
      console.log(mesh);
      return console.log(inter);
    };

    Testing.prototype.test_mesh = function(a, b, c) {
      var geometry, material, mesh;
      geometry = new THREE.Geometry();
      geometry.vertices.push(a, b, c);
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      material = new THREE.MeshBasicMaterial({
        color: 0xffff00
      });
      return mesh = new THREE.Mesh(geometry, material);
    };

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Math = {};

  TSAG.Math.distance = function(x1, y1, x2, y2) {
    return Math.sqrt(TSAG.Math.distance_sqr(x1, y1, x2, y2));
  };

  TSAG.Math.distance_sqr = function(x1, y1, x2, y2) {
    var dx, dy;
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.M_Road = (function() {
    function M_Road(t0, t11, road) {
      this.t0 = t0;
      this.t1 = t11;
      this.road = road;
    }

    M_Road.prototype.getPosition = function() {
      return this.road.getPosition((this.t0 + t1) / 2);
    };

    return M_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(.5, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Square;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(TSAG.Mesh_Basic);

}).call(this);

/*
 * Entry Point to my Transportation Simulation Game.
 * Sets up THREE.js on the DOM and sets up input from the browser.
 * Written by Bryce Summers on 11/22/2016
 */

var renderer;
var root_e_scene;
var root_camera;

var input;
var root_AABB;

function init()
{
    // run some Tests.
    new TSAG.Testing();

    // Initialize all of the global material, mesh constructor's, etc.
    TSAG.init_style();

    // Scene Graph.
    root_e_scene = new TSAG.E_Scene(window.innerWidth, window.innerHeight);

    // Camera.
    var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 2;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))


    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Clear to white Background.
    // FIXME: Use a Style Class.
    // FIXME: Move this to a background prropery of the E_Scene.
    renderer.setClearColor( 0xD8C49E );

    init_input();
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( window.devicePixelRatio );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    // Initialize the root of the input specification tree.
    input = new TSAG.I_All_Main(root_e_scene, root_camera);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);
}

// Events.
function onWindowResize( event )
{
    renderer.setSize( window.innerWidth, window.innerHeight );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
}

function onMouseMove( event )
{
    input.mouse_move(event);
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    if(isRightMB)
        return

    input.mouse_down(e);
}

function onMouseUp( event )
{
    input.mouse_up(event);
}

function animate()
{
    requestAnimationFrame( animate );
    render();
}

function render()
{
    renderer.render(root_e_scene.getVisual(), root_camera);
}

init();
animate();