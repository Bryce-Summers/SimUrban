/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 23-10-2017
 */
// All of the boiler plate, example project stuff should be out of a namespace.
// all of the procedural elements unique to a project should be within this projects' specific namespace.

// Defined main namespace.
EX = {};// Example namespace. Necessary for coffeescript files.
        // EX contains demo specific files that are not usable as an api for other projects, but which may be useful for setting up demos for other projects.

/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
TSAG = {};
// Generated by CoffeeScript 1.11.1

/*
 *
 * Element interface class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * A Game element consists of the following:
 * - Model that represents fundamental game state.
 * - Representations that provide information to the user about the model.
 *
 * Representations include:
 * Visual: Provide spatial information, decoration, character, etc.
 * Auditory: Provide mood, quick feedback, etc.
 * Interfacial: A representation of collision geometry, etc. that allows the user to provide inputs that influence the model.
 *
 * Element classes are responsible for providing useful features for building various common combinations of models and representations,
 * such as a path tied to a polygon, tied to a collision geometry.
 *
 * There is only ever 1 model, but there can be many elements.
 */

(function() {
  TSAG.Element = (function() {
    function Element(model) {
      this.model = model;
      this._view = new THREE.Object3D();
      this._visual = null;
    }

    Element.prototype.getVisualRepresentation = function() {
      return this._visual;
    };

    Element.prototype.setVisualRepresentation = function(visual) {
      this._visual = visual;
      this._view.remove(this._visual);
      this._view.add(this._visual);
    };

    Element.prototype.getAudioRepresentation = function() {
      return console.log("Please Implement me!");
    };

    Element.prototype.allowMutations = function() {
      return console.log("Please Implement me!");
    };

    Element.prototype.getUIWindow = function() {
      return console.log("Please Implement me!");
    };

    return Element;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Path_Element = (function(superClass) {
    extend(Path_Element, superClass);

    function Path_Element(model, polyline, width, fill_color) {
      Path_Element.__super__.constructor.call(this, model);
      this._polyline = null;
      this._width = null;
    }

    Path_Element.prototype.getLocation = function(percentage) {};

    return Path_Element;

  })(TSAG.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Place_Element = (function(superClass) {
    extend(Place_Element, superClass);

    function Place_Element(model) {
      Place_Element.__super__.constructor.call(this, model);
      this.init();
    }

    Place_Element.prototype.init = function() {
      this._places = new Set();
      this._junctions = new Set();
      this._conditions = new Set();
      this._paths = new Set();
      this._operators = new Set();
      this._visual_places = new THREE.Object3D();
      this._visual_junctions = new THREE.Object3D();
      this._visual_paths = new THREE.Object3D();
      this._visual_operators = new THREE.Object3D();
      return this._visual_conditions = new THREE.Object3D();
    };

    Place_Element.prototype.populateViewLevels = function(levels, N) {
      levels[1].add(this._visual_places);
      levels[1].add(this._visual_junctions);
      levels[2].add(this._visual_paths);
      levels[3].add(this._visual_operators);
      return levels[3].add(this._visual_conditions);

      /*
      @_places.forEach (element) =>
          levels[1].add(element.getVisualRepresentation())
      
      @_junctions.forEach (element) =>
          levels[1].add(element.getVisualRepresentation())
      
      @_paths.forEach (element) =>
          levels[2].add(element.getVisualRepresentation())
      
      @_operators.forEach (element) =>
          levels[3].add(element.getVisualRepresentation())
      @_conditions.forEach (element) =>
          levels[3].add(element.getVisualRepresentation())
       */
    };

    Place_Element.prototype.addPlace = function(element) {
      this._places.add(element);
      return this._visual_places.add(element.getVisualRepresentation());
    };

    Place_Element.prototype.addJunction = function(element) {
      this._junction.add(element);
      return this._visual_junctions.add(element.getVisualRepresentation());
    };

    Place_Element.prototype.addCondition = function(element) {
      this._conditions.add(element);
      return this._visual_conditions.add(element.getVisualRepresentation());
    };

    Place_Element.prototype.addPath = function(element) {
      this._paths.add(element);
      return this._visual_paths.add(element.getVisualRepresentation());
    };

    Place_Element.prototype.addOperator = function(element) {
      this._operators.add(element);
      return this._visual_operators.add(element.getVisualRepresentation());
    };

    Place_Element.prototype.removePlace = function(element) {
      this._places["delete"](element);
      return this._visual_places.remove(element.getVisualRepresentation());
    };

    Place_Element.prototype.removeJunction = function(element) {
      this._junction["delete"](element);
      return this._visual_junctions.remove(element.getVisualRepresentation());
    };

    Place_Element.prototype.removeCondition = function(element) {
      this._conditions["delete"](element);
      return this._visual_conditions.remove(element.getVisualRepresentation());
    };

    Place_Element.prototype.removePath = function(element) {
      this._paths["delete"](element);
      return this._visual_paths.remove(element.getVisualRepresentation());
    };

    Place_Element.prototype.removeOperator = function(element) {
      this._operators["delete"](element);
      return this._visual_operators.remove(element.getVisualRepresentation());
    };

    return Place_Element;

  })(TSAG.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban Scene Object.
    Rewritten by Bryce Summers on 10.23.2017
    
    purpose: Organizes my algorithm authoring document system.
             This is the root node of all game initialization, storage, and references.

    NOTE: Objects and places are indistinguishable, except that objects are meant to be temporary,
        whereas places are meant to be eternal.
        Places may spawn objects.
 */

(function() {
  TSAG.Scene = (function() {
    function Scene() {
      this.view = new THREE.Scene();
      this._view_levels = null;
      this._io_root = null;
      this.init();
    }

    Scene.prototype.getVisualRepresentation = function() {
      return this.view;
    };

    Scene.prototype.init = function() {
      var i, j, level, results;
      this._objects = new Set();
      this._active_objects = new Set();
      this._places = new Set();
      this._active_places = new Set();
      this._view_levels = [];
      results = [];
      for (i = j = 1; j < 10; i = ++j) {
        level = new THREE.Object3D();
        level.position.z = 1.0 / 10 * i;
        this._view_levels.push(level);
        results.push(this.view.add(level));
      }
      return results;
    };

    Scene.prototype.setViewToPlace = function(place) {
      var j, len, level, ref;
      ref = this._view_levels;
      for (j = 0, len = ref.length; j < len; j++) {
        level = ref[j];
        while (level.children.length > 0) {
          level.children.pop();
        }
      }
      return place.populateViewLevels(this._view_levels, 10);
    };

    Scene.prototype.setInputRoot = function(io_root) {
      var view;
      this._io_root = io_root;
      this._io_mouse_main = this._io_root.getMouseController();
      view = this.getVisual();
      this._ui = new TSAG.E_UI_Game(this);
      return view.add(this._ui.getVisual());
    };

    Scene.prototype.update = function(dt) {
      this._active_objects.forEach((function(_this) {
        return function(obj_model) {
          return obj_model.update(dt);
        };
      })(this));
    };

    Scene.prototype.activateObject = function(obj_model) {
      this._active_objects.add(obj_model);
    };

    Scene.prototype.deactivateObject = function(obj_model) {
      this._active_objects["delete"](obj_model);
    };

    Scene.prototype.newObject = function(obj_model) {
      this._objects.add(obj_model);
    };

    Scene.prototype.destroyObject = function(obj_model) {
      this._objects["delete"](obj_model);
    };

    Scene.prototype.activatePlace = function(model) {
      return this._active_places.add(model);
    };

    Scene.prototype.deactivatePlace = function(model) {
      return this._active_places["delete"](model);
    };

    Scene.prototype.addPlace = function(model) {
      return this._places.add(model);
    };

    Scene.prototype.deletePlace = function(model) {
      return this._places["delete"](model);
    };

    return Scene;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      this.outline_geometry = outline_geometry;
      this.fill_material = EX.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, this.fill_material);
      this.line_material = EX.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new EX.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (params.material) {
        mesh.material = params.material;
      }
      if (params.color) {
        if (!(params.color instanceof THREE.Color)) {
          debugger;
        }
        mesh.material.color = params.color;
      }
      output.setFillColor = function(c) {
        return this.children[0].material.color = c;
      };
      output.revertFillColor = function() {
        return this.children[0].material.color = EX.style.m_default_fill.color.clone();
      };
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new EX.Mesh_Unit_Square();
      this._circle = new EX.Mesh_Unit_Circle();
      this._triangle = new EX.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Model Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 10.23.2017
 */

(function() {
  TSAG.Model = (function() {
    function Model(_element) {
      this._element = _element;
      this._ui = null;
    }

    Model.prototype.listNeighbors = function() {
      return console.log("Please Implement me!");
    };

    Model.prototype.heuristicTo = function(element) {
      return console.log("Please Implement me!");
    };

    Model.prototype.getLocation = function() {
      return console.log("Please Implement me!");
    };

    Model.prototype.getElement = function() {
      return this._element;
    };

    return Model;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A Model for a current camera view of a place.
    These are preserved between visits to places.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Camera_Model = (function(superClass) {
    extend(Camera_Model, superClass);

    function Camera_Model() {}

    Camera_Model.prototype.buildModel = function() {};

    return Camera_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    Conditional models allow either accept or reject a given object model depending
    this conditional model's prediated test configuration.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Condition_Model = (function(superClass) {
    extend(Condition_Model, superClass);

    Condition_Model.EQ = "=";

    Condition_Model.LE = "<=";

    Condition_Model.GE = ">=";

    Condition_Model.LT = "<";

    Condition_Model.GT = ">";

    Condition_Model.NE = "!=";

    Condition_Model.VAR = 0;

    Condition_Model.CONSTANT = 1;

    function Condition_Model(key1, type1, operator, key2, type2) {
      this.key1 = key1;
      this.type1 = type1;
      this.operator = operator;
      this.key2 = key2;
      this.type2 = type2;
    }

    Condition_Model.prototype.buildModel = function() {};

    Condition_Model.prototype.evaluateObject = function(obj) {
      var val1, val2;
      if (this.type1 === TSAG.Condition_Model.VAR) {
        val1 = obj.lookup(this.key1);
      } else {
        val1 = this.key1;
      }
      if (this.type2 === TSAG.Condition_Model.VAR) {
        val2 = obj.lookupKey(this.key2);
      } else {
        val2 = this.key2;
      }
      switch (this.operator) {
        case TSAG.Condition_Model.EQ:
          return val1 === val2;
        case TSAG.Condition_Model.LE:
          return val1 <= val2;
        case TSAG.Condition_Model.GE:
          return val1 >= val2;
        case TSAG.Condition_Model.LT:
          return val1 < val2;
        case TSAG.Condition_Model.GT:
          return val1 > val2;
        case TSAG.Condition_Model.NE:
          return val1 !== val2;
        default:
          return console.log("Conditional: " + this.operator + " is not defined.");
      }
    };

    return Condition_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Junction_Model = (function(superClass) {
    extend(Junction_Model, superClass);

    function Junction_Model() {
      this._configurations = null;
    }

    Junction_Model.prototype.buildModel = function() {};

    return Junction_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for the navigation of an object.

    This handles all of the logic for location and the creation of plans.
    Objects determine when to plan.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Navigation_Model = (function(superClass) {
    extend(Navigation_Model, superClass);

    function Navigation_Model(src, dest) {
      this.current_location_model = src;
      this.destination = dest;
      this.plan_stack = [];
      this.finished_plan_stack = [];
      this.buildModel();
    }

    Navigation_Model.prototype.updatePlan = function() {};

    Navigation_Model.prototype.get_current_location = function() {
      return this.current_location_model;
    };

    return Navigation_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    Objects are agents that try to do stuff. They carry along data, then sleep.

    Objects are responsible for determining when statistics ought to be logged,
    when plans should be created, and for following the rules.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Object_Model = (function(superClass) {
    extend(Object_Model, superClass);

    function Object_Model(scene) {
      this.scene = scene;
      this.active = null;
      this.state = null;
      this.statistics = null;
      this.navigation = null;
      this.percentage = 0;
      this.representation = null;
    }

    Object_Model.prototype.buildModel = function() {
      this.statistics = new TSAG.Statistics_Model();
      this.navigation = new TSAG.Navigation_Model();
      this.representation = new TSAG.Representation(this);
      this.percentage = 0;
      this.state = {};
      return this.active = false;
    };

    Object_Model.prototype.update = function(dt) {
      return this.navigation.move(dt);
    };

    Object_Model.prototype.activate = function() {
      this.scene.activateObject(this);
      return this.active = true;
    };

    Object_Model.prototype.deactivate = function() {
      this.scene.deactivateObject(this);
      return this.active = false;
    };

    Object_Model.prototype.lookupKey = function(key) {
      return this.state[key];
    };

    Object_Model.prototype.setKey = function(key, val) {
      this.state[key] = val;
    };

    return Object_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Operator_Model = (function(superClass) {
    extend(Operator_Model, superClass);

    function Operator_Model() {
      this._mutation_function = null;
    }

    Operator_Model.prototype.buildModel = function() {};

    return Operator_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Path_Model = (function(superClass) {
    extend(Path_Model, superClass);

    function Path_Model(capacity, transversal_cost) {
      this._capacity = capacity;
      this._occupancy = 0;
      this._cost = transversal_cost;
      this.destination = null;
      this.last_object = null;
    }

    Path_Model.prototype.isClear = function() {
      return this._occupancy === 0;
    };

    return Path_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Place Class.
    Defines a place model.
    Written by Bryce Summers on 10.23.2017
        
    The User is always viewing a visual representation of a place model.
    There are also a set of active places currently in the model hiearchy handled by the scene object.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Place_Model = (function(superClass) {
    extend(Place_Model, superClass);

    function Place_Model() {
      this._object_spawners = null;
    }

    return Place_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for the statistics of an object.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Statistics_Model = (function(superClass) {
    extend(Statistics_Model, superClass);

    function Statistics_Model() {}

    Statistics_Model.prototype.buildModel = function() {};

    return Statistics_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for a User Interface.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.UI_Model = (function(superClass) {
    extend(UI_Model, superClass);

    function UI_Model() {}

    UI_Model.prototype.buildModel = function() {};

    return UI_Model;

  })(TSAG.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Model Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Test_Place = (function(superClass) {
    extend(Test_Place, superClass);

    function Test_Place() {
      var place_model, pts, square, square_mesh, square_place;
      Test_Place.__super__.constructor.call(this, new TSAG.Place_Model());
      place_model = new TSAG.Place_Model();
      pts = [new BDS.Point(0, 0), new BDS.Point(100, 0), new BDS.Point(100, 100), new BDS.Point(0, 100)];
      square = new BDS.Polyline(true, pts);
      square_mesh = EX.Visual_Factory.newPolygon(square, new THREE.Color(1, 0, 0));
      square_place = new TSAG.Place_Element(place_model);
      square_place.setVisualRepresentation(square_mesh);
      this.addPlace(square_place);
    }

    return Test_Place;

  })(TSAG.Place_Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Representation Interface class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * Specifies the capabilities of all visual representations.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Representation = (function(superClass) {
    extend(Representation, superClass);

    function Representation() {}

    return Representation;

  })(THREE.Object3D);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Written on Oct.07.2017 by Bryce Summers
Purpose: Creates THREE.js paths.
 */

(function() {
  EX.Path_Visual_Factory = (function() {
    function Path_Visual_Factory(polyline, width, color, show_outline) {
      this.vecs = this._BDS_Polyline_to_THREE_vertex_list(polyline);
      this.width = width;
      this.color = color;
      this.spline = new THREE.CatmullRomCurve3(this.vecs);
      this.curve = new BDS.Curve(this.spline);
      this.show_outline = show_outline;
    }

    Path_Visual_Factory.prototype.getPathVisual = function() {
      return this.getVisual(1, this.curve, this.width, this.color);
    };

    Path_Visual_Factory.prototype.getVisual = function(max_length, curve, width, color) {
      var fill, fill_geometry, fill_material, fill_mesh, left_line, material, middle_material, offset_amount, output, right_line, times_left, times_right, verts_left, verts_right;
      offset_amount = width / 2;
      curve.updateDiscretization(max_length);
      material = EX.style.m_default_line.clone();
      material.color = EX.style.c_default_line;
      middle_material = EX.style.m_default_line.clone();
      middle_material.color = EX.style.c_default_line;

      /*
      middle_line = new THREE.Geometry()
      middle_line.vertices = curve.getDiscretization()
       */
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = EX.style.m_flat_fill.clone();
      fill_material.color = color;
      this.fill_material = fill_material;
      output = new THREE.Object3D();
      fill = new THREE.Object3D();
      output.add(fill);
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      output.add(fill_mesh);
      if (this.show_outline) {
        output.add(new THREE.Line(left_line, material));
        output.add(new THREE.Line(right_line, material));
      }
      return output;
    };

    Path_Visual_Factory.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    Path_Visual_Factory.prototype._BDS_Polyline_to_THREE_vertex_list = function(polyline) {
      var i, len, pt, pts, vec, vecs;
      pts = polyline.toPoints();
      vecs = [];
      for (i = 0, len = pts.length; i < len; i++) {
        pt = pts[i];
        vec = new THREE.Vector3(pt.x, pt.y, pt.z);
        vecs.push(vec);
      }
      if (polyline.isClosed()) {
        pt = pts[0];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
        pt = pts[1];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      return vecs;
    };

    Path_Visual_Factory.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len = vectors.length; i < len; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    return Path_Visual_Factory;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Representation Class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * Provides the universal functionality for visually representing and interactively querying elements.
 */

(function() {
  TSAG.Representation = (function() {
    function Representation(_model) {
      this._model = _model;
      this._view = new Object3D();
      this._bvh = new BDS.BVH2D();
      this._collision_polygon = null;
    }

    Representation.prototype.getVisual = function() {
      return this._view;
    };

    Representation.prototype.addVisual = function(subview) {
      return this._view.add(subview);
    };

    Representation.prototype.removeVisual = function(subview) {
      return this._view.remove(subview);
    };

    Representation.prototype.addCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.addCollisionPolygon(aPolygon));
      }
      return results;
    };

    Representation.prototype.addCollisionPolygon = function(polygon) {
      return this._bvh.add(polygon);
    };

    Representation.prototype.removeCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.removeCollisionPolygon(aPolygon));
      }
      return results;
    };

    Representation.prototype.removeCollisionPolygon = function(polygon) {
      return this._bvh.remove(polygon);
    };

    Representation.prototype.generateBVH = function() {
      var polylines;
      polylines = this._to_collision_polygons();
      return this._bvh = new BDS.BVH2D(polylines);
    };

    Representation.prototype.generateCollisionPolygon = function() {
      this._collision_polygon = this._bvh.toBoundingBox().toPolyline();
      this._collision_polygon.setAssociatedData(this);
      return this._collision_polygon;
    };

    Representation.prototype.getCollisionPolygon = function() {
      if (this._collision_polygon === null) {
        this.generateCollisionPolygon();
      }
      return this._collision_polygon;
    };

    Representation.prototype._to_collision_polygons = function(output) {
      var a, b, c, face, faces, geometry, i, j, len, len1, localToWorld, mesh, mesh_list, obj, polyline, polyline_list, vertices;
      obj = this._view;
      mesh_list = this._to_mesh_list(obj);
      polyline_list = [];
      if (output !== void 0) {
        polyline_list = output;
      }
      for (i = 0, len = mesh_list.length; i < len; i++) {
        mesh = mesh_list[i];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (j = 0, len1 = faces.length; j < len1; j++) {
          face = faces[j];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          a = this._vector_to_point(a);
          b = this._vector_to_point(b);
          c = this._vector_to_point(c);
          polyline = new BDS.Polyline(true, [a, b, c]);
          polyline.setAssociatedData(this);
          polyline_list.push(polyline);
        }
      }
      return polyline_list;
    };

    Representation.prototype._vector_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y, vec.z);
    };

    Representation.prototype._to_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    Representation.prototype.setFillColor = function(c) {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    Representation.prototype.revertFillColor = function() {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    Representation.prototype.setPosition = function(position) {
      var z;
      z = this._view.position.z;
      this._view.position.copy(position.clone());
      return this._view.position.z = z;
    };

    Representation.prototype.setRotation = function(rotation_z) {
      return this._view.rotation.z = rotation_z;
    };

    Representation.prototype.getRotation = function() {
      return this._view.rotation.z;
    };

    Representation.prototype.setScale = function(scale) {
      return this._view.scale.copy(scale.clone());
    };

    Representation.prototype.getPosition = function() {
      return this._view.position.clone();
    };

    Representation.prototype.containsPt = function(pt) {
      return this._bvh.query_point(pt) !== null;
    };

    return Representation;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  EX.init_style = function() {
    EX.style = {
      radius_road_local: 50,
      radius_road_collector: 75,
      radius_road_artery: 100,
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      m_flat_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_car_fill: new THREE.Color(0x00aaaa),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0,
      dz_cars: .02,
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000),
      action: new THREE.Color(0x72E261),
      c_normal: new THREE.Color(0xdddddd)
    };
    EX.style.fontLoader = new THREE.FontLoader();
    return EX.style.fontLoader.load('fonts/Raleway_Regular.typeface.json', function(font) {
      var i, len, params, ref, results;
      EX.style.font = font;
      ref = EX.Visual_Factory.textMeshQueue;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        params = ref[i];
        results.push(EX.style.newText(params));
      }
      return results;
    });
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Written by Bryce Summers on 10.23.2017
 * 
 * Allows THREE.js visuals to be built from polylines, polygons, strings, etc.
 */

(function() {
  EX.Visual_Factory = (function() {
    function Visual_Factory() {
      EX.Visual_Factory.unit_meshes = new EX.Unit_Meshes();
    }


    /*
         * Local Variables.
    
         * Root of THREE.JS visualization.
        @scene = new THREE.Scene()
        
         * Simple Meshes, such as circles creator.
        @unit_meshes = new BDS.Unit_Meshes(EX.style.m_flat_fill, EX.style.m_flat_fill, EX.style.m_default_line)
    
        #@init_test_scene()
        @input_root = null
    
        @init_test_bryce_image()
    
    init_test_scene: () ->
    
         * Test Line on the screen.
        pts = [new BDS.Point(0, 0), new BDS.Point(100, 100), new BDS.Point(500, 100)]
        polyline = new BDS.Polyline(false, pts)
        @newCurve(polyline, new THREE.Color(0, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(0, 200), new BDS.Point(100, 300), new BDS.Point(500, 300)]
        polyline = new BDS.Polyline(false, pts)
        @newPath(polyline, 50, new THREE.Color(1, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(500, 500), new BDS.Point(600, 500), new BDS.Point(550, 700)]
        polyline = new BDS.Polyline(false, pts)
        @newPolygon(polyline, 50, new THREE.Color(0, 0, 1))
        @newPoint(new BDS.Point(800, 350), new THREE.Color(0, 0, 1))
     */

    Visual_Factory.unit_meshes = null;

    Visual_Factory.textMeshQueue = [];

    Visual_Factory.textureLoader = new THREE.TextureLoader();

    Visual_Factory.newCurve = function(polyline, color) {
      var geom, k, len, line_material, mesh, pt, pts;
      if (polyline.size() < 2) {
        return;
      }
      geom = new THREE.Geometry();
      pts = polyline.toPoints();
      if (polyline.isClosed()) {
        pts.push(pts[0]);
      }
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        geom.vertices.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      line_material = EX.style.m_default_line.clone();
      line_material.color = color.clone();
      mesh = new THREE.Line(geom, line_material);
      return mesh;
    };

    Visual_Factory.newPath = function(polyline, width, color, show_outline) {
      var mesh, pathFactory;
      if (!show_outline) {
        show_outline = false;
      }
      if (polyline.size() < 2 || (polyline.isClosed() && polyline.size < 3)) {
        return null;
      }
      pathFactory = new EX.Path_Visual_Factory(polyline, width, color, show_outline);
      mesh = pathFactory.getPathVisual();
      return mesh;
    };

    Visual_Factory.newPolygon = function(polygon, color) {
      var geometry, k, len, material, mesh, pt, pts, shape, vecs;
      pts = polygon.toPoints();
      vecs = [];
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      shape = new THREE.Shape(vecs);
      geometry = new THREE.ShapeGeometry(shape);
      material = EX.style.m_flat_fill.clone();
      mesh = new THREE.Mesh(geometry, material);
      return mesh;
    };

    Visual_Factory.newPoint = function(pt, color, radius) {
      var material, mesh, pos, scale;
      scale = new THREE.Vector3(radius, radius, 1);
      pos = new THREE.Vector3(pt.x, pt.y, 1);
      material = EX.style.m_flat_fill.clone();
      mesh = this.unit_meshes.newCircle({
        color: color,
        material: material,
        position: pos,
        scale: scale
      });
      return mesh;
    };


    /*
    
    External API.
     */

    Visual_Factory.setInputRoot = function(input) {
      var input_root;
      return input_root = input;
    };

    Visual_Factory.getVisual = function() {
      return this.scene;
    };

    Visual_Factory.new_label = function(str) {
      var obj, params;
      obj = new THREE.Object3D();
      params = {
        font: EX.style.fontLoader,
        message: str,
        height: 20,
        out: obj,
        fill_color: 0x000000,
        outline_color: 0x111111
      };
      EX.Visual_Factory.newText(params);
      obj.position.copy(new THREE.Vector3(-50, 20, -100));
      obj.scale.copy(new THREE.Vector3(1, -1, 1));
      obj.rotation.copy(new THREE.Vector3(0, 0, Math.PI / 2));
      return obj;
    };


    /*
    EX.style.load_texture = (url) ->
        material = new THREE.MeshBasicMaterial( {
            map: null
         } );
    
        loader = new THREE.TextureLoader();
    
         * load the resource
        loader.load(
            url,
            (texture) ->
                 * Color map the material to the loaded texture.
                material.map = texture
    
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set( 40, 40);
            ,
            (xhr) ->
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )
            ,
             * Function called when download errors
            ( xhr ) ->
                console.log( "The texture at url: " + url + "  was not loaded." )
        )
    
        return material
     */

    Visual_Factory.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = EX.Visual_Factory.loader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };

    Visual_Factory.newText = function(params) {
      var geometry, message, shapes;
      if (!EX.style.font) {
        EX.Visual_Factory.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = EX.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        EX.Visual_Factory.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        EX.Visual_Factory.newOutlineText(params, shapes, geometry);
      }
      return params.out.position.z = +.1;
    };

    Visual_Factory.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      geometry.scale(1, -1, 1);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };

    Visual_Factory.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      params.out.position.z = +.1;
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.scale(1, -1, 1);
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };

    return Visual_Factory;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers on 12 - 16 - 2016.
 */


/*
 * Testing Axis Aligned Bounding Box.
 */

(function() {
  EX.Testing = (function() {
    function Testing() {}

    Testing.prototype.test_AABB = function() {
      var AABB, direction, geometry, i, inter, mesh, origin, ray, ref, scene, x, y;
      scene = new THREE.Scene();
      geometry = new THREE.Geometry();
      y = 0;
      for (x = i = 0; i <= 10; x = ++i) {
        mesh = this.test_mesh(new THREE.Vector3(x * 3 + 0, y * 3 + 1, 0), new THREE.Vector3(x * 3 + -1, y * 3 - 1, 0), new THREE.Vector3(x * 3 + 1, y * 3 - 1, 0));
        scene.add(mesh);
      }
      AABB = new TSAG.AABB(scene, {
        val: 'x',
        dim: 2
      });
      origin = new THREE.Vector3(0, 0, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      ref = AABB.collision_query(ray), mesh = ref[0], inter = ref[1];
      console.log(mesh);
      return console.log(inter);
    };

    Testing.prototype.test_mesh = function(a, b, c) {
      var geometry, material, mesh;
      geometry = new THREE.Geometry();
      geometry.vertices.push(a, b, c);
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      material = new THREE.MeshBasicMaterial({
        color: 0xffff00
      });
      return mesh = new THREE.Mesh(geometry, material);
    };

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(radius, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(EX.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }


    /*
    setup_texture_coordinates: () ->
        @geometry.faceVertexUvs.push(uv_coords)
    
        s = 1
    
        v1 = new THREE.Vector2(0, 0)
        v2 = new THREE.Vector2(s, 0)
        v3 = new THREE.Vector2(s, s)
        v4 = new THREE.Vector2(0, s)
    
        uv_coords.push([v1, v2, v3])
        uv_coords.push([v1, v3, v4])
    
        @geometry.uvsNeedUpdate = true
    
        @geometry.computeBoundingSphere()
    
        @geometry.computeFaceNormals()
        @geometry.computeVertexNormals()
        
        @geometry.verticesNeedUpdate = true
                
         * Changes to Vertex normals.
        @geometry.normalsNeedUpdate = true
        @geometry.colorsNeedUpdate = true
     */

    return Mesh_Unit_Square;

  })(EX.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(EX.Mesh_Basic);

}).call(this);

/*
 * Entry Point to demo.
 * Pipes THREE.js and browser IO to game.
 * Written by Bryce Summers on 11/22/2016
 * Refactored by Bryce on 10.23.2017
 */

var renderer;
var root_scene;
var root_camera;

var input;
var root_AABB;

function init()
{
    // run some Tests.
    new EX.Testing();

    // Initialize all of the global material, mesh constructor's, etc.
    EX.init_style();

    init_camera();

    // Initialize Demo through the scene node.
    root_scene = new TSAG.Scene();
    
    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Set Renderer background clear color.
    renderer.setClearColor( 0xD8C49E );

    // FIXME: Re-enable input when we have tested it some more.
    //init_input();

    new EX.Visual_Factory()
    
    // Initialize the initial game state using the test place.
    var place = new TSAG.Test_Place();
    root_scene.addPlace(place);
    root_scene.setViewToPlace(place);
}

function init_camera()
{
    // Camera.
    //var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    // Fixed reolution viewport.
    dim = {x:0, y:0, w:1200, h:800, padding:10};
   
    // I may want to change to a perspective camera if we want to start showing depth information.
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 2;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( dim.w / dim.h /*window.devicePixelRatio*/ );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    // Initialize the root of the input specification tree.
    input = new TSAG.I_All_Main(root_scene, root_camera);

    // Provide the scene with a hook into the io tree.
    root_scene.setInputRoot(input);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);

    // The current system time, used to correctly pass time deltas.
    TIMESTAMP = performance.now();

    // Initialize Time input.
    beginTime();

    TIME_ON = true;
}

function beginTime()
{
    TIMESTAMP = performance.now();
    TIME_ON   = true;
    timestep();
}

function timestep()
{
    if(TIME_ON)
    {
        requestAnimationFrame(timestep)
    }
    else
    {
        return;
    }

    time_new = performance.now()
    var dt = time_new - TIMESTAMP
    TIMESTAMP = time_new

    try
    {
        input.time(dt)
    }
    catch(err)
    { // Stop time on error.
        TIME_ON = false
        throw err
    }

}

// Events.
function onWindowResize( event )
{
    //renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( dim.w, dim.h );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
}

function onMouseMove( event )
{
    input.mouse_move(translateEvent(event));
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    if(isRightMB)
        return

    input.mouse_down(translateEvent(e));
}

function onMouseUp( event )
{
    input.mouse_up(translateEvent(event));
}

function animate()
{
    requestAnimationFrame( animate );
    render();
}

function render()
{
    renderer.render(root_scene.getVisualRepresentation(), root_camera);
}

// Since we are using a fixed size screen, we will need to translate the events.
function translateEvent(event)
{
    return {x: event.x -= window.innerWidth/2 - dim.w/2,
            y: event.y/* -= window.innerHeight/2 - dim.h/2*/}
}

init();
animate();