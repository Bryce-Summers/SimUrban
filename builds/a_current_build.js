/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 06-04-2017
 */
/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
TSAG = {};

// Generated by CoffeeScript 1.11.1

/*
 *
 * Element Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Some Elements will have pointers to Scribble Elements.
 * All elements contain an @_view object that is a renderable THREE.js scene node.
 * All elements also contain an BDS.AABVH @_BVH object that stores versions of this element's geometry for collision detection.
 */

(function() {
  TSAG.E_Super = (function() {
    function E_Super(_view) {
      this._view = _view;
      if (!this._view) {
        this._view = new THREE.Object3D();
      }
      this._bvh = new BDS.BVH2D();
      this._collision_polygon = null;
      if (!this._topology) {
        this._topology = null;
      }
    }

    E_Super.prototype.isTemporary = function() {
      return this._topology === null;
    };

    E_Super.prototype.getVisual = function() {
      return this._view;
    };

    E_Super.prototype.setTopology = function(_topology) {
      this._topology = _topology;
    };

    E_Super.prototype.getTopology = function() {
      return this._topology;
    };

    E_Super.prototype.addVisual = function(subview) {
      return this._view.add(subview);
    };

    E_Super.prototype.removeVisual = function(subview) {
      return this._view.remove(subview);
    };

    E_Super.prototype.addCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.addCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.addCollisionPolygon = function(polygon) {
      return this._bvh.add(polygon);
    };

    E_Super.prototype.removeCollisionPolygons = function(polygons) {
      var aPolygon, i, len, results;
      results = [];
      for (i = 0, len = polygons.length; i < len; i++) {
        aPolygon = polygons[i];
        results.push(this.removeCollisionPolygon(aPolygon));
      }
      return results;
    };

    E_Super.prototype.removeCollisionPolygon = function(polygon) {
      return this._bvh.remove(polygon);
    };

    E_Super.prototype.generateBVH = function() {
      var polylines;
      polylines = this._to_collision_polygons();
      return this._bvh = new BDS.BVH2D(polylines);
    };

    E_Super.prototype.generateCollisionPolygon = function() {
      this._collision_polygon = this._bvh.toBoundingBox().toPolyline();
      this._collision_polygon.setAssociatedData(this);
      return this._collision_polygon;
    };

    E_Super.prototype.getCollisionPolygon = function() {
      if (this._collision_polygon === null) {
        this.generateCollisionPolygon();
      }
      return this._collision_polygon;
    };

    E_Super.prototype._to_collision_polygons = function(output) {
      var a, b, c, face, faces, geometry, i, j, len, len1, localToWorld, mesh, mesh_list, obj, polyline, polyline_list, vertices;
      obj = this._view;
      mesh_list = this._to_mesh_list(obj);
      polyline_list = [];
      if (output !== void 0) {
        polyline_list = output;
      }
      for (i = 0, len = mesh_list.length; i < len; i++) {
        mesh = mesh_list[i];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (j = 0, len1 = faces.length; j < len1; j++) {
          face = faces[j];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          a = this._vector_to_point(a);
          b = this._vector_to_point(b);
          c = this._vector_to_point(c);
          polyline = new BDS.Polyline(true, [a, b, c]);
          polyline.setAssociatedData(this);
          polyline_list.push(polyline);
        }
      }
      return polyline_list;
    };

    E_Super.prototype._vector_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y, vec.z);
    };

    E_Super.prototype._to_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    E_Super.prototype.setFillColor = function(c) {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.revertFillColor = function() {
      var err;
      err = new Error("This method should be overriden in a subclass.");
      console.log(err.stack);
      debugger;
      throw err;
    };

    E_Super.prototype.setPosition = function(position) {
      var z;
      z = this._view.position.z;
      this._view.position.copy(position.clone());
      return this._view.position.z = z;
    };

    E_Super.prototype.setRotation = function(rotation_z) {
      return this._view.rotation.z = rotation_z;
    };

    E_Super.prototype.getRotation = function() {
      return this._view.rotation.z;
    };

    E_Super.prototype.setScale = function(scale) {
      return this._view.scale.copy(scale.clone());
    };

    E_Super.prototype.getPosition = function() {
      return this._view.position.clone();
    };

    E_Super.prototype.getAgents = function(out) {
      throw new Error("Destroy is unimplemented for this element!!!");
    };

    E_Super.prototype.containsPt = function(pt) {
      return this._bvh.query_point(pt) !== null;
    };

    return E_Super;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Area element.

Game elements that are topologically associated with faces.
 */

(function() {


}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Building Element Class.
 * 
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 * Purpose: This class specifies the gameplay and aesthetic properties of building objects.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Building = (function(superClass) {
    extend(E_Building, superClass);

    function E_Building(position, scale, rotation_z) {
      var _position, _rz, mesh, view;
      E_Building.__super__.constructor.call(this);
      view = this.getVisual();
      _position = position;
      _rz = rotation_z;
      mesh = this._newHouse({
        color: TSAG.style.c_building_fill
      });
      mesh.position.copy(position.clone());
      mesh.scale.copy(scale.clone());
      mesh.rotation.z = rotation_z;
      this._mesh = mesh;
      view.add(mesh);
    }

    E_Building.prototype._newHouse = function(params) {
      var mesh_factory, node, square, triangle;
      mesh_factory = TSAG.style.unit_meshes;
      square = mesh_factory.newSquare(params);
      triangle = mesh_factory.newTriangle(params);
      triangle.position.x = .5;
      triangle.scale.x = .5;
      node = new THREE.Object3D();
      node.add(square);
      node.add(triangle);
      return node;
    };

    E_Building.prototype.rotateBuilding = function(dr) {
      this.getVisual().remove(this._mesh);
      this._mesh.rotation.z = this._mesh.rotation.z + dr;
      return this.getVisual().add(this._mesh);
    };

    return E_Building;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Car Element Class.
 * 
 * Written by Bryce Summers on 1 - 31 - 2017.
 *
 * Purpose: This class specifies the gameplay and aesthetic properties of building objects.
 *
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Car = (function(superClass) {
    extend(E_Car, superClass);

    function E_Car(scale) {
      E_Car.__super__.constructor.call(this);
      this.createVisual(scale);
      this.resetLaneInfo();
    }

    E_Car.prototype.resetLaneInfo = function() {
      this.distance = 0.0;
      this.segment_index = 0;
      return this.next_car = null;
    };

    E_Car.prototype.createVisual = function(scale) {
      var mesh, view;
      view = this.getVisual();
      mesh = this._newCar({
        color: TSAG.style.c_car_fill
      });
      view.add(mesh);
      view.position.z = TSAG.style.dz_cars;
      return this.setScale(scale);
    };

    E_Car.prototype._newCar = function(params) {
      var mesh_factory, square;
      mesh_factory = TSAG.style.unit_meshes;
      square = mesh_factory.newSquare(params);
      square.scale.x = 2;
      return square;
    };

    return E_Car;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Intersection = (function(superClass) {
    extend(E_Intersection, superClass);

    function E_Intersection(position) {
      var fill, sx, sy, view;
      E_Intersection.__super__.constructor.call(this);
      this._position = position;
      fill = TSAG.style.unit_meshes.newSquare({
        color: TSAG.style.c_road_fill
      });
      fill.position.copy(new THREE.Vector3(position.x, position.y, 0));
      sx = sy = TSAG.style.road_offset_amount * 2;
      fill.scale.copy(new THREE.Vector3(sx, sy, 1));
      view = this.getVisual();
      view.add(fill);
      view.position.z = TSAG.style.dz_intersection;
      this.generateBVH();
    }

    E_Intersection.prototype.addRoad = function(road) {
      var edge;
      edge = road.getEdge();
      return true;
    };

    E_Intersection.prototype.getPoint = function() {
      return this._position.clone();
    };

    E_Intersection.prototype.getIncomingHalfedgeFrom = function(src_vert) {
      return this.getOutgoingHalfedgeTo(src_vert).twin;
    };

    E_Intersection.prototype.getOutgoingHalfedgeTo = function(dest_vert) {
      var current, road, src_vert, start;
      src_vert = this.getTopology();
      start = src_vert.halfedge;
      current = start;
      while (true) {
        road = current.edge.data.element;
        if (road.hasEndPoint(dest_vert)) {
          return current;
        }
        current = current.twin.next;
        if (current === start) {
          break;
        }
      }
      debugger;
      throw new Error("Halfedge not Found!");
    };

    return E_Intersection;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Network = (function(superClass) {
    extend(E_Network, superClass);

    function E_Network() {
      var graph;
      E_Network.__super__.constructor.call(this);
      this._topology_generator = new TSAG.TopologyGenerator();
      graph = this._topology_generator.allocateGraph();
      this._topology_linker = new SCRIB.TopologyLinker(this._topology_generator, graph);
      this.setTopology(graph);
      this._roads = new Set();
    }

    E_Network.prototype.addRoad = function(road) {
      return this._roads.add(road);
    };

    E_Network.prototype.removeRoad = function(road) {
      var agent, agents, i, len, results;
      this._roads["delete"](road);
      agents = [];
      road.getAgents(agents);
      results = [];
      for (i = 0, len = agents.length; i < len; i++) {
        agent = agents[i];
        results.push(this.removeVisual(agent.getVisual()));
      }
      return results;
    };

    E_Network.prototype.getRoads = function() {
      var out;
      out = [];
      this._roads.forEach((function(_this) {
        return function(road) {
          return out.push(road);
        };
      })(this));
      return out;
    };

    E_Network.prototype.getGenerator = function() {
      return this._topology_generator;
    };

    E_Network.prototype.getLinker = function() {
      return this._topology_linker;
    };

    E_Network.prototype.query_elements_pt = function(x, y) {
      var element, elements, i, len, polyline, polylines, pt;
      pt = new BDS.Point(x, y);
      polylines = this._bvh.query_point_all(pt);
      elements = [];
      for (i = 0, len = polylines.length; i < len; i++) {
        polyline = polylines[i];
        element = polyline.getAssociatedData();
        if (element.containsPt(pt)) {
          elements.push(element);
        }
      }
      return elements;
    };

    E_Network.prototype.query_elements_box = function(box) {
      var elements, i, len, polyline, polylines;
      polylines = this._bvh.query_box_all(box);
      elements = [];
      for (i = 0, len = polylines.length; i < len; i++) {
        polyline = polylines[i];
        elements.push(polyline.getAssociatedData());
      }
      return elements;
    };

    return E_Network;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Road = (function(superClass) {
    extend(E_Road, superClass);

    function E_Road() {
      var visual;
      E_Road.__super__.constructor.call(this);
      this._main_curve = new TSAG.S_Curve();
      visual = this.getVisual();
      visual.position.z = TSAG.style.dz_road;
      this.fill_material = TSAG.style.m_default_fill.clone();
      this._road_visual = null;
      this._center_polyline = null;
      this.lanes = [];
      this.vert_start = null;
      this.vert_end = null;
      this.halfedge = null;
      this.reverts = [];
    }

    E_Road.prototype.setStartVertex = function(vert) {
      return this.vert_start = vert;
    };

    E_Road.prototype.getStartVertex = function() {
      return this.vert_start;
    };

    E_Road.prototype.setHalfedge = function(halfedge) {
      return this.halfedge = halfedge;
    };

    E_Road.prototype.getHalfedge = function() {
      return this.halfedge;
    };

    E_Road.prototype.setEndVertex = function(vert) {
      return this.vert_end = vert;
    };

    E_Road.prototype.getEndVertex = function() {
      return this.vert_end;
    };

    E_Road.prototype.hasEndPoint = function(vert) {
      return this.vert_start === vert || this.vert_end === vert;
    };

    E_Road.prototype.addPoint = function(pt) {
      this._main_curve.addPoint(pt);
      return true;
    };

    E_Road.prototype.getLastPoint = function() {
      return this._main_curve.getLastPoint();
    };

    E_Road.prototype.getPenultimatePoint = function() {
      var len;
      len = this._main_curve.numPoints();
      return this._main_curve.getPointAtIndex(len - 2);
    };

    E_Road.prototype.numPoints = function() {
      return this._main_curve.numPoints();
    };

    E_Road.prototype.getPointAtIndexFromEnd = function(index) {
      var len;
      len = this._main_curve.numPoints();
      return this._main_curve.getPointAtIndex(len - 1 - index);
    };

    E_Road.prototype.removeLastPoint = function() {
      return this._main_curve.removeLastPoint();
    };

    E_Road.prototype.setRevert = function() {
      return this.reverts.push({
        index: this._main_curve.numPoints(),
        point2: this.getLastPoint(),
        point1: this.getPenultimatePoint()
      });
    };

    E_Road.prototype.revert = function() {
      var revert_obj;
      revert_obj = this.revertObj();
      while (this._main_curve.numPoints() > revert_obj.index - 2) {
        this.removeLastPoint();
      }
      this.addPoint(revert_obj.point1);
      return this.addPoint(revert_obj.point2);
    };

    E_Road.prototype.revertObj = function() {
      return this.reverts[this.reverts.length - 1];
    };

    E_Road.prototype.updateLastPoint = function(pt) {
      this.removeLastPoint();
      return this.addPoint(pt);
    };

    E_Road.prototype.getPosition = function(time) {
      return this._main_curve.position(time);
    };

    E_Road.prototype.updateDiscretization = function(max_length) {
      this.updateVisual(max_length);
      return this.generateBVH();
    };

    E_Road.prototype.updateVisual = function(max_length) {
      var fill_geometry, fill_material, fill_mesh, left_line, material, middle_line, middle_material, offset_amount, right_line, times_left, times_right, verts_left, verts_right, visual;
      offset_amount = TSAG.style.road_offset_amount;
      this._main_curve.updateDiscretization(max_length);
      visual = this.getVisual();
      visual.remove(this._road_visual);
      this._road_visual = new THREE.Object3D();
      visual.add(this._road_visual);
      material = TSAG.style.m_default_line.clone();
      material.color = TSAG.style.c_road_outline;
      middle_material = TSAG.style.m_default_line.clone();
      middle_material.color = TSAG.style.c_road_midline;
      middle_line = new THREE.Geometry();
      middle_line.vertices = this._main_curve.getDiscretization();
      this._center_polyline = this._THREE_vertex_list_to_BDS_Polyline(middle_line.vertices);
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = this._main_curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = this._main_curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = TSAG.style.m_default_fill.clone();
      fill_material.color = TSAG.style.c_road_fill;
      this.fill_material = fill_material;
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      this._road_visual.add(fill_mesh);
      this._road_visual.add(new THREE.Line(middle_line, middle_material));
      this._road_visual.add(new THREE.Line(left_line, material));
      this._road_visual.add(new THREE.Line(right_line, material));
      return this.updateLaneStructures(max_length, offset_amount, times_left, times_right);
    };

    E_Road.prototype.updateLaneStructures = function(max_length, offset_amount, times_left, times_right) {
      var left_lane, left_lane_polyline, left_lane_vectors, right_lane, right_lane_polyline, right_lane_vectors;
      left_lane_vectors = this._main_curve.getOffsets(max_length, offset_amount / 2, times_left);
      right_lane_vectors = this._main_curve.getOffsets(max_length, -offset_amount / 2, times_right);
      left_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(left_lane_vectors);
      right_lane_polyline = this._main_curve.threeVectorsToBDSPolyline(right_lane_vectors);
      right_lane = new TSAG.S_Lane(right_lane_polyline, false, this.vert_start, this.vert_end);
      left_lane = new TSAG.S_Lane(left_lane_polyline, true, this.vert_end, this.vert_start);
      this.lanes = [];
      this.lanes.push(right_lane);
      return this.lanes.push(left_lane);
    };

    E_Road.prototype.setFillColor = function(c) {
      return this.fill_material.color = c;
    };

    E_Road.prototype.revertFillColor = function() {
      return this.fill_material.color = TSAG.style.c_road_fill;
    };

    E_Road.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        face.model = new TSAG.M_Road(this.t0, this.t1, this.road);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    E_Road.prototype.getCenterPolyline = function() {
      return this._center_polyline;
    };

    E_Road.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len1, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len1 = vectors.length; i < len1; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    E_Road.prototype.getLanes = function() {
      return this.lanes;
    };

    E_Road.prototype.getAgents = function(out) {
      var i, lane, len1, ref, results;
      ref = this.lanes;
      results = [];
      for (i = 0, len1 = ref.length; i < len1; i++) {
        lane = ref[i];
        results.push(lane.getAgents(out));
      }
      return results;
    };

    E_Road.prototype.addCar = function(car, vert) {
      if (vert === this.vert_start) {
        return this.lanes[0].addCar(car);
      } else {
        return this.lanes[1].addCar(car);
      }
    };

    E_Road.prototype.getWidth = function() {
      return TSAG.style.road_offset_amount * this.lanes.length;
    };

    E_Road.prototype.getClosePointOnCenterLine = function(pt) {
      var dir, end_vertex, half_width, halfedge, p1, p2, par, perp, pt_on_road, ray, ref, v1, v2;
      halfedge = this.getHalfedge();
      end_vertex = this.getEndVertex();
      half_width = this.getWidth() / 2;
      while (halfedge.vertex !== end_vertex) {
        v1 = halfedge.vertex;
        v2 = halfedge.twin.vertex;
        p1 = v1.data.point;
        p2 = v2.data.point;
        dir = p2.sub(p1);
        ray = new BDS.Ray(p1, dir);
        ref = ray.getPerpAndParLengths(pt), perp = ref[0], par = ref[1];
        if (perp <= half_width && par >= 0 && par <= 1) {
          pt_on_road = ray.getPointAtTime(par);
          return [pt_on_road, halfedge.edge];
        }
        halfedge = halfedge.next;
      }
      return [null, null];
    };

    return E_Road;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban Scene Object.
    Written by Bryce on 11/22/2016
    Refactored by Bryce on 12 - 18 - 2016.
    
    Purpose: This class organizes all of the structural layers in the game.
        It serves as the root of the scene graph for all rendering.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_Scene = (function(superClass) {
    extend(E_Scene, superClass);

    function E_Scene(scene_width, scene_height) {
      var view;
      E_Scene.__super__.constructor.call(this, new THREE.Scene());
      view = this.getVisual();
      this._network = new TSAG.E_Network();
      view.add(this._network.getVisual());
      this._overlays = new THREE.Object3D();
      this._overlays.name = "Overlays";
      view.add(this._overlays);
      this.initializeMessageText();
    }

    E_Scene.prototype.initializeMessageText = function() {
      var text2;
      text2 = document.createElement('div');
      text2.style.position = 'absolute';
      text2.style.zIndex = 1;
      text2.style.width = 100;
      text2.style.height = 100;
      text2.style.backgroundColor = "blue";
      text2.innerHTML = "[Blank]";
      text2.style.top = 0 + 'px';
      text2.style.left = 0 + 'px';
      document.body.appendChild(text2);
      return this.message_text = text2;
    };

    E_Scene.prototype.constructRandomBuildings = function() {
      var building, h, i, j, pos, rz, scale, w, x, y;
      this._building_visuals = new THREE.Object3D();
      this._building_visuals.name = "Building Visuals";
      view.add(this._building_visuals);
      this._buildings = [];
      this._scale = 40;
      this._padding = 30;
      for (i = j = 0; j < 10; i = ++j) {
        x = this._padding + Math.random() * (scene_width - this._padding * 2);
        y = this._padding + Math.random() * (scene_height - this._padding * 2);
        w = this._scale;
        h = this._scale;
        rz = Math.random() * Math.PI * 2;
        pos = new THREE.Vector3(x, y, 0);
        scale = new THREE.Vector3(w, h, 1);
        building = new TSAG.E_Building(pos, scale, rz);
        this._buildings.push(building);
        this._building_visuals.add(building.getVisual());
      }
    };

    E_Scene.prototype.addOverlayVisual = function(obj) {
      return this._overlays.add(obj);
    };

    E_Scene.prototype.removeOverlayVisual = function(obj) {
      return this._overlays.remove(obj);
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.getMeshFactory = function() {
      return TSAG.style.unit_meshes;
    };

    E_Scene.prototype.getNetwork = function() {
      return this._network;
    };

    E_Scene.prototype.getBuildings = function() {
      return this._buildings;
    };

    E_Scene.prototype.getRoads = function() {
      return this._roads;
    };

    E_Scene.prototype.ui_message = function(str, params) {
      if (params.type === 'info') {
        this.message_text.style.backgroundColor = "blue";
        if (params.element) {
          params.element.revertFillColor();
        }
      } else if (params.type === 'error') {
        this.message_text.style.backgroundColor = "red";
        if (params.element) {
          params.element.setFillColor(TSAG.style.error);
        }
      }
      this.message_text.innerHTML = str;
    };

    return E_Scene;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban User Interface Object.
    Written by Bryce on 4.6.2017
    
    Purpose: This class organizes the drawing and functionality for all of the static user interface elements,
        such as windows, buttons, etc.

        This class also handles the text based display of information to the users.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.E_UI = (function(superClass) {
    extend(E_UI, superClass);

    function E_UI() {
      var b1, b2, b3, func_build_road_artery, func_build_road_collector, func_build_road_local, img_build_road_artery, img_build_road_collector, img_build_road_local, p1, p2;
      E_UI.__super__.constructor.call(this);
      this.controller_ui = new BDS.Controller_UI(canvas_G);
      this.controller_build_road = this.controller_build_road.setActive(false);
      this.controller_demolish_road = this.controller_demolish_road.setActive(false);
      b1 = new BDS.Box(new BDS.Point(0, 0), new BDS.Point(64, 64));
      b2 = new BDS.Box(new BDS.Point(64, 0), new BDS.Point(128, 64));
      b3 = new BDS.Box(new BDS.Point(128, 0), new BDS.Point(192, 64));
      p1 = b1.toPolyline();
      p2 = b2.toPolyline();
      func_build_road_local = function() {};
      func_build_road_collector = function() {};
      func_build_road_artery = function() {};
      img_build_road_local = null;
      img_build_road_collector = null;
      img_build_road_artery = null;
      controller_ui.createButton(p1, func_build_road_local, img_build_road_local);
      controller_ui.createButton(p2, func_build_road_collector, img_build_road_collector);
      controller_ui.createButton(p2, func_build_road_artery, img_build_road_artery);
    }

    return E_UI;

  })(TSAG.E_Super);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Lane Elements

Written by Bryce Summers on 2 - 1 - 2017.

Purpose: This class contains handles the movement of cars along a lane.

queues cars through lane.
Parameterizes car movement:
 - t space [0:start, 1:end]      # Percentage space, needed for coorespondence with alternate lanes.
 - s space [0:start, length:end] # Distance space,   needed for realistic movement of vehicles.
 */

(function() {
  TSAG.S_Lane = (function() {
    function S_Lane(polyline, reverse, _start_vert, _end_vert) {
      this._start_vert = _start_vert;
      this._end_vert = _end_vert;
      this.cars = new BDS.SingleLinkedList();
      if (reverse) {
        polyline.reverse();
      }
      this.cumulative_lengths = polyline.computeCumulativeLengths();
      this.angles = polyline.computeTangentAngles();
      this.tangents = polyline.computeUnitTangents();
      this.points = polyline.toPoints();
    }

    S_Lane.prototype.getStartVert = function() {
      return this._start_vert;
    };

    S_Lane.prototype.getEndVert = function() {
      return this._end_vert;
    };

    S_Lane.prototype.addCar = function(car) {
      return this.cars.enqueue(car);
    };

    S_Lane.prototype.moveCars = function() {
      var car, destroyed_cars, iter;
      destroyed_cars = [];
      iter = this.cars.iterator();
      while (iter.hasNext()) {
        car = iter.next();
        if (!this._moveCar(car, 1)) {
          iter.remove();
          destroyed_cars.push(car);
        }
      }
      return destroyed_cars;
    };

    S_Lane.prototype._accelerateCar = function(car) {};

    S_Lane.prototype._moveCar = function(car, change_in_distance) {
      var car_position, index, local_distance, local_point, local_tangent, new_angle, next_length, old_angle;
      index = car.segment_index;
      car.distance += change_in_distance;
      while (true) {
        next_length = this.cumulative_lengths[index + 1];
        if (!(car.distance >= next_length)) {
          break;
        }
        index += 1;
        if (index === this.cumulative_lengths.length) {
          return false;
        }
      }
      if (index >= this.points.length - 1) {
        return false;
      }
      local_distance = car.distance - this.cumulative_lengths[index];
      local_point = this.points[index];
      local_tangent = this.tangents[index];
      if (!local_tangent) {
        debugger;
      }
      car_position = local_point.add(local_tangent.multScalar(local_distance));
      old_angle = car.getRotation();
      new_angle = this.angles[index];
      if (new_angle - old_angle > Math.PI) {
        new_angle -= Math.PI * 2;
      }
      if (old_angle - new_angle > Math.PI) {
        new_angle += Math.PI * 2;
      }
      new_angle = old_angle * .7 + new_angle * .3;
      car.setPosition(car_position);
      car.segment_index = index;
      car.setRotation(new_angle);
      return true;
    };

    S_Lane.prototype.getAgents = function(out) {
      var car, iter;
      iter = this.cars.iterator();
      while (iter.hasNext()) {
        car = iter.next();
        out.push(car);
      }
    };

    S_Lane.prototype.isEmpty = function() {
      return this.cars.isEmpty();
    };

    S_Lane.prototype.deadStart = function() {
      return this._start_vert.degree() === 1;
    };

    S_Lane.prototype.deadEnd = function() {
      return this._end_vert.degree() === 1;
    };

    return S_Lane;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_All_Main = (function(superClass) {
    extend(I_All_Main, superClass);

    function I_All_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_All_Main.__super__.constructor.call(this);
      this._mouse_input = new TSAG.I_Mouse_Main(this.scene, this.camera);
      this.add_mouse_input_controller(this._mouse_input);
      this._time_input = new TSAG.I_Time_Main(this.scene, this.camera);
      this.add_time_input_controller(this._time_input);
    }

    return I_All_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Build_Road = (function() {
    function I_Mouse_Build_Road(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = TSAG.style.user_input_min_move;
      this.road = null;
      this.legal = false;
      this.next_point = null;
      this.network = this.e_scene.getNetwork();
      this._generator = this.network.getGenerator();
      this._linker = this.network.getLinker();
      this.isects = [];
      this.isects_last_segment = [];
    }

    I_Mouse_Build_Road.prototype.isIdle = function() {
      return this.state === "idle";
    };

    I_Mouse_Build_Road.prototype.mouse_down = function(event) {
      var dist, isect, isect_obj, j, last_isect, len1, max_length, pos, pt, ref, x, y;
      if (this.state === "idle") {
        this.road = new TSAG.E_Road();
        this.network.addVisual(this.road.getVisual());
        pt = new BDS.Point(event.x, event.y);
        isect_obj = this.classify_or_construct_intersection(pt);
        this.start_or_end_point(isect_obj);
        this.isects.push(isect_obj);
        pt = isect_obj.point;
        x = pt.x;
        y = pt.y;
        this.road.addPoint(new THREE.Vector3(x, y, 0));
        this.next_point = new THREE.Vector3(x, y + 1, 0);
        this.road.addPoint(this.next_point);
        this.road.setRevert();
        max_length = TSAG.style.discretization_length;
        this.road.updateVisual(max_length);
        this.state = "building";
        this._mousePrevious.x = event.x;
        this._mousePrevious.y = event.y;
      } else if (this.state === "building") {

        /*
        if not @legal()
             * Play an error noise, flash the road, etc.
             * Let the user know that this is an erroneous action.
            return
         */
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.next_point;
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          pt = new BDS.Point(pos.x, pos.y);
          isect_obj = this.classify_or_construct_intersection(pt);
          pos = isect_obj.point;
          this.road.updateLastPoint(pos);
          this.next_point = new THREE.Vector3(pos.x + .01, pos.y + .01, 0);
          this.road.addPoint(this.next_point);
          this._mousePrevious.x = event.x;
          this._mousePrevious.y = event.y;
          if (this.isects[this.isects.length - 1].type === 'i') {
            this.isects.pop();
          }
          ref = this.isects_last_segment;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            isect = ref[j];
            this.isects.push(isect);
          }
          this.isects_last_segment = [];
          last_isect = this.isects[this.isects.length - 1];
          dist = last_isect.point.distanceTo(isect_obj.point);
          if (dist > this.road.getWidth()) {
            this.isects.push(isect_obj);
          } else if (isect_obj.isect !== void 0) {
            this.network.removeVisual(isect_obj.isect.getVisual());
          }
          this.road.setRevert();
        } else {
          this.finish();
        }
      }
    };

    I_Mouse_Build_Road.prototype.classify_or_construct_intersection = function(pt) {
      var edge, element, err, intersection, isect_pt, out, ref, road;
      element = this._getIsectOrRoadAtPt(pt);
      out = null;
      if (element instanceof TSAG.E_Intersection) {
        isect_pt = element.getPoint();
        out = {
          isect: start_element,
          type: 'p',
          point: isect_pt
        };
      } else if (element instanceof TSAG.E_Road) {
        road = element;
        ref = road.getClosePointOnCenterLine(pt), pt = ref[0], edge = ref[1];
        if (pt === null) {
          err = new Error("Pt was not actually inside of the road proper. Check you collision detection and bounds.");
          console.log(err.stack);
          debugger;
          throw err;
        }
        intersection = new TSAG.E_Intersection(pt);
        out = {
          isect: intersection,
          type: 's',
          road_edge: edge,
          point: intersection.getPoint()
        };
        this.network.addVisual(out.isect.getVisual());
      } else {
        out = {
          type: 'i',
          point: pt
        };
      }
      return out;
    };

    I_Mouse_Build_Road.prototype.start_or_end_point = function(isect_obj) {
      var intersection, pt;
      if (isect_obj.type === 'i') {
        pt = isect_obj.point;
        intersection = new TSAG.E_Intersection(pt);
        this.network.addVisual(intersection.getVisual());
        isect_obj.isect = intersection;
        return isect_obj.type = 't';
      }
    };

    I_Mouse_Build_Road.prototype.mouse_up = function(event) {};

    I_Mouse_Build_Road.prototype.mouse_move = function(event) {
      var dir, dist, i1, i2, len, p1, p2, pt, ray;
      if (this.state === "building") {
        this.e_scene.ui_message("Building Road.", {
          type: 'info',
          element: this.road
        });
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist <= this._min_dist) {
          if (this.isects.length <= 2) {
            this.e_scene.ui_message("Click to cancel road.", {
              type: 'info',
              element: this.road
            });
          } else {
            this.e_scene.ui_message("Click to complete road.", {
              type: 'info',
              element: this.road
            });
          }
          return;
        }
        this.next_point.x = event.x + .01;
        this.next_point.y = event.y + .01;
        len = this.isects.length;
        if (len > 1) {
          i1 = this.isects[len - 1];
          if (i1.type !== 'i') {
            i2 = this.isects[len - 2];
            p1 = i1.point;
            p2 = i2.point;
            dir = p2.sub(p1);
            ray = new BDS.Ray(p1, dir);
            pt = this.vec_to_pt(this.next_point);
            pt = ray.projectPoint(pt);
            this.next_point = this.pt_to_vec(pt);
          }
        }
        return this.updateTemporaryRoad();
      }
    };

    I_Mouse_Build_Road.prototype.finish = function() {
      var collision_polygon, end_pt, i, isect, isect_obj, isects, j, k, l, last_isect, len, len1, len2, len3, m, max_length, obj1, obj2, ref, ref1, ref2, ref3, road, road_edge, split_isect, split_vert, type, vert, vert1, vert2, x, y;
      if (this.state !== "building") {
        return;
      }
      this.state = "idle";
      this.e_scene.ui_message("", {
        type: "info"
      });
      if (this.isects.length < 2) {
        this._cancel();
        return;
      }
      this.road.removeLastPoint();
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      end_pt = this.road.getLastPoint();
      x = end_pt.x;
      y = end_pt.y;
      last_isect = this.isects[this.isects.length - 1];
      this.start_or_end_point(last_isect);
      this.network.removeVisual(this.road.getVisual());
      this.road = null;

      /*
      for isect_obj in @isects
          if isect_obj.type != 'p'
              @network.removeVisual(isect_obj.isect.getVisual())
       */
      ref = this.isects;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        isect_obj = ref[j];
        type = isect_obj.type;
        if (type !== 'p' && type !== 'i') {
          isect = isect_obj.isect;
          collision_polygon = isect.getCollisionPolygon();
          this.network.addCollisionPolygon(collision_polygon);
        }
      }
      ref1 = this.isects;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        isect_obj = ref1[k];
        if (isect_obj.type !== 's') {
          continue;
        }
        road_edge = isect_obj.road_edge;
        road = road_edge.data.element;
        this.network.removeVisual(road.getVisual());
        this.network.removeCollisionPolygon(road.getCollisionPolygon());
        this.network.removeRoad(road);
        split_vert = this._generator.newVertex();
        split_isect = isect_obj.isect;
        split_vert.data.point = split_isect.getPoint();
        isect_obj.type = 'p';
        split_isect.setTopology(split_vert);
        split_vert.data.element = split_isect;
        this._linker.split_edge_with_vert(road_edge, split_vert);
        isects = this._populate_split_path(road, split_vert);
        this.construct_roads_along_isect_path(isects);
      }
      ref2 = this.isects;
      for (l = 0, len3 = ref2.length; l < len3; l++) {
        isect_obj = ref2[l];
        if (isect_obj.type === 'p') {
          isect_obj.vert = isect_obj.isect.getTopology();
          continue;
        }
        vert = this._generator.newVertex();
        if (isect_obj.type !== 'i') {
          isect = isect_obj.isect;
          isect.setTopology(vert);
          vert.data.element = isect;
          vert.data.point = isect.getPoint();
        } else {
          vert.data.point = isect_obj.point;
        }
        isect_obj.vert = vert;
        continue;
      }
      len = this.isects.length;

      /*
      for i = 0; i < len - 1; i++
       */
      for (i = m = 0, ref3 = len - 1; m < ref3; i = m += 1) {
        obj1 = this.isects[i];
        obj2 = this.isects[i + 1];
        vert1 = obj1.vert;
        vert2 = obj2.vert;
        this._linker.link_verts(vert1, vert2);
      }
      this.construct_roads_along_isect_path(this.isects);

      /*
      
       * 2. Use the linker to link this graph.
      
       * 3. Create Roads and associate intersections.
       *    Associate every road with a path.
       *    The roads need to have arc curve, instead of the temporary solution that we have right now.
       *    This can come later.
      
      
       * Add the road's collision polygons to the network BVH.
       * FIXME: Add a bounding polygon instead.
      @network.addCollisionPolygons(@road.to_collision_polygons())
      
       * Make all intersections collidable.
      for isect_obj in @isects
          isect = isect_obj.isect
          @network.addCollisionPolygon(isect.getCollisionPolygon())
      
       * Embed the road topology between the list of intersections.
       * This will enable vehicles to move on the new road,
       * it will also update the areas.
      #@embedRoadTopology()
      
       * FIXME: Make a better way of managing roads.
      @network.addRoad(@road)
      
       * Preserve the road object.
      @road = null
       */
      this.isects = [];
      this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype._cancel = function() {
      var isect_obj, j, k, len1, len2, ref, ref1;
      if (this.road) {
        this.network.removeVisual(this.road.getVisual());
      }
      ref = this.isects_last_segment;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        isect_obj = ref[j];
        this.isects.push(isect_obj);
      }
      ref1 = this.isects;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        isect_obj = ref1[k];
        if (isect_obj.type !== 'i') {
          this.network.removeVisual(isect_obj.isect.getVisual());
        }
      }
      this.road = null;
      this.isects = [];
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype._populate_split_path = function(road, split_vert) {
      var halfedge, isect_obj, isects, vert1, vert2, vert3;
      vert1 = road.getStartVertex();
      vert2 = split_vert;
      vert3 = road.getEndVertex();
      isects = [];
      halfedge = vert1.get_outgoing_halfedge_to(split_vert);
      if (halfedge === null) {
        halfedge = road.getHalfedge();
      }
      isect_obj = {
        isect: vert1.data.element,
        type: 'p',
        point: vert1.data.point,
        vert: vert1
      };
      isects.push(isect_obj);
      halfedge = this._append_intermediate_isects_until_vert(halfedge.next, vert2, isects);
      isect_obj = {
        isect: vert2.data.element,
        type: 's',
        point: vert2.data.point,
        vert: vert2
      };
      isects.push(isect_obj);
      halfedge = this._append_intermediate_isects_until_vert(halfedge.next, vert3, isects);
      isect_obj = {
        isect: vert3.data.element,
        type: 'p',
        point: vert3.data.point,
        vert: vert3
      };
      isects.push(isect_obj);
      return isects;
    };

    I_Mouse_Build_Road.prototype._append_intermediate_isects_until_vert = function(halfedge, stop_vert, output) {
      var c_isect, c_point, c_vert, isect_obj;
      while (true) {
        c_vert = halfedge.vertex;
        if (c_vert === stop_vert) {
          break;
        }
        c_isect = c_vert.data.element;
        c_point = c_vert.data.point;
        isect_obj = {
          isect: c_isect,
          type: 'i',
          point: c_point,
          vert: c_vert
        };
        output.push(isect_obj);
        halfedge = halfedge.next;
      }
      return halfedge;
    };

    I_Mouse_Build_Road.prototype.construct_roads_along_isect_path = function(isects) {
      var _road, edge, halfedge, i, isect_obj, j, prev_isect_obj, ref, vert, vert_prev;
      _road = new TSAG.E_Road();
      this.network.addVisual(_road.getVisual());
      _road.addPoint(isects[0].point);
      _road.setStartVertex(isects[0].vert);
      for (i = j = 1, ref = isects.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        isect_obj = isects[i];
        prev_isect_obj = isects[i - 1];
        vert_prev = prev_isect_obj.vert;
        vert = isect_obj.vert;
        halfedge = vert_prev.get_outgoing_halfedge_to(vert);
        edge = halfedge.edge;
        edge.data.element = _road;
        _road.addPoint(isect_obj.point);
        if (_road.getHalfedge() === null) {
          _road.setHalfedge(halfedge);
        }
        if (isect_obj.type === 'i') {
          vert.data.element = _road;
          continue;
        }
        _road.setEndVertex(vert);
        _road.updateDiscretization(TSAG.style.discretization_length);
        this.network.addCollisionPolygon(_road.getCollisionPolygon());
        this.network.addRoad(_road);
        _road = null;
        if (isect_obj.type === 't') {
          break;
        }
        _road = new TSAG.E_Road();
        this.network.addVisual(_road.getVisual());
        _road.addPoint(isect_obj.point);
        _road.setStartVertex(vert);
        continue;
      }
    };

    I_Mouse_Build_Road.prototype.updateTemporaryRoad = function() {
      var max_length;
      this.destroyLastSegmentIsects();
      this.road.updateLastPoint(this.next_point);
      max_length = TSAG.style.discretization_length;
      this.road.updateDiscretization(max_length);
      if (!this.checkLegality()) {
        this.road.setFillColor(TSAG.style.error);
        this.legal = false;
        return;
      }
      this.road.revertFillColor();
      this.legal = true;
      this.createTempIntersections();
      return this.road.updateDiscretization(max_length);
    };

    I_Mouse_Build_Road.prototype.destroyLastSegmentIsects = function() {
      var collision_polygon, isect, isect_obj, j, len1, ref;
      this.road.revert();
      ref = this.isects_last_segment;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        isect_obj = ref[j];
        if (isect_obj.type !== 's') {
          continue;
        }
        isect = isect_obj.isect;
        this.network.removeVisual(isect.getVisual());
        collision_polygon = isect.getCollisionPolygon();
        this.network.removeCollisionPolygon(collision_polygon);
      }
      return this.isects_last_segment = [];
    };

    I_Mouse_Build_Road.prototype.checkLegality = function() {
      var collision_polygon, query_box;
      collision_polygon = this.road.generateCollisionPolygon();
      return query_box = collision_polygon.generateBoundingBox();
    };

    I_Mouse_Build_Road.prototype.createTempIntersections = function() {
      var dir1, dir2, e_polyline, e_road, elem, elements, far_enough, isect_obj, j, last_intersection_point, last_point, len, len1, polyline, pt1, pt2, pt3, query_box, temp_polyline;
      polyline = this.road.getCenterPolyline();
      temp_polyline = polyline.getLastSegment();
      query_box = temp_polyline.generateBoundingBox();
      elements = this.network.query_elements_box(query_box);
      for (j = 0, len1 = elements.length; j < len1; j++) {
        elem = elements[j];
        if (elem instanceof TSAG.E_Road) {
          e_polyline = elem.getCenterPolyline();
          this._intersectPolygons(e_polyline, temp_polyline, elem);
        }
      }
      last_point = temp_polyline.getLastPoint();
      far_enough = true;
      if (this.isects_last_segment.length > 0) {
        last_intersection_point = this.isects_last_segment[this.isects_last_segment.length - 1].point;
        far_enough = last_intersection_point.distanceTo(last_point) > this.road.getWidth();
      }
      e_road = this._getRoadAtPt(last_point);
      if (e_road !== null && far_enough) {
        isect_obj = this.classify_or_construct_intersection(last_point);
        this.network.addVisual(isect_obj.isect.getVisual());
        this.isects_last_segment.push(isect_obj);
      }
      if (this.isects.length >= 2 && this.isects[this.isects.length - 1].type === 'i') {
        len = this.isects.length;
        pt1 = this.isects[len - 2].point;
        pt2 = this.isects[len - 1].point;
        if (this.isects_last_segment.length > 0) {
          pt3 = this.isects_last_segment[0].point;
        } else {
          pt3 = last_point;
        }
        dir1 = pt1.sub(pt2);
        dir2 = pt3.sub(pt2);
        if (dir1.angleBetween(dir2) < Math.PI / 2) {
          this.road.revert();
          this.e_scene.ui_message("Error: Curve is too sharp!", {
            type: "error",
            element: this.road
          });
          return;
        }
        this.road.removeLastPoint();
        last_point = this.road.removeLastPoint();
        this._createTempCurve(pt1, pt2, pt3);
        this.road.addPoint(this.next_point);
      }
    };

    I_Mouse_Build_Road.prototype._createTempCurve = function(pt0, pt1, pt2) {
      var prefix;
      prefix = this._arc(pt0, pt1, pt2, TSAG.style.radius_speed1);
      this.isects_last_segment = prefix.concat(this.isects_last_segment);
    };

    I_Mouse_Build_Road.prototype._arc = function(pt0, pt1, pt2, radius) {
      var angle, angle1, angle2, angle_diff, arc_center_pt, arc_length, curve_pts, dir01, dir21, i, isect_obj, isects, j, k, len, len1, offset_pt0, offset_pt2, offset_ray01, offset_ray21, orientation, perp_dir_pt0, perp_dir_pt2, pt, ray01, ray21, ref, seg_length, temp;
      dir01 = pt1.sub(pt0);
      dir21 = pt1.sub(pt2);
      ray01 = new BDS.Ray(pt0, dir01);
      ray21 = new BDS.Ray(pt2, dir21);
      orientation = ray01.line_side_test(pt2);
      orientation = BDS.Math.sign(orientation);
      if (orientation === 0) {
        return [];
      }
      perp_dir_pt0 = ray01.getRightPerpendicularDirection().multScalar(orientation);
      perp_dir_pt0 = perp_dir_pt0.normalize();
      offset_pt0 = pt0.add(perp_dir_pt0.multScalar(radius));
      perp_dir_pt2 = ray21.getLeftPerpendicularDirection().multScalar(orientation);
      perp_dir_pt2 = perp_dir_pt2.normalize();
      offset_pt2 = pt2.add(perp_dir_pt2.multScalar(radius));
      offset_ray01 = new BDS.Ray(offset_pt0, dir01);
      offset_ray21 = new BDS.Ray(offset_pt2, dir21);
      arc_center_pt = offset_ray01.intersect_ray(offset_ray21);
      if (arc_center_pt === null) {
        return [];
      }
      angle1 = perp_dir_pt0.multScalar(-1).angle();
      angle2 = perp_dir_pt2.multScalar(-1).angle();
      seg_length = TSAG.style.discretization_length;
      curve_pts = [];
      if (orientation < 0) {
        temp = angle1;
        angle1 = angle2;
        angle2 = temp;
      }
      if (angle2 < angle1) {
        angle2 += Math.PI * 2;
      }
      angle_diff = angle2 - angle1;
      arc_length = radius * angle_diff;
      len = Math.ceil(arc_length / seg_length);
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        angle = angle1 + i * (angle2 - angle1) / len;
        pt = BDS.Point.directionFromAngle(angle);
        curve_pts.push(arc_center_pt.add(pt.multScalar(radius)));
      }
      if (orientation < 0) {
        curve_pts = curve_pts.reverse();
      }
      isects = [];
      for (k = 0, len1 = curve_pts.length; k < len1; k++) {
        pt = curve_pts[k];
        isect_obj = {
          type: 'i',
          point: pt
        };
        isects.push(isect_obj);
        this.road.addPoint(this.pt_to_vec(pt));
      }
      return isects;
    };

    I_Mouse_Build_Road.prototype._quadraticBezier = function(pt0, pt1, pt2) {
      var b1, b2, d1, d2, d3, isect_obj, isects, j, pt, t, time;
      isects = [];
      d1 = pt1.sub(pt0);
      d2 = pt2.sub(pt1);
      for (t = j = 1; j < 10; t = ++j) {
        time = t / 10.0;
        b1 = pt0.add(d1.multScalar(time));
        b2 = pt1.add(d2.multScalar(time));
        d3 = b2.sub(b1);
        pt = b1.add(d3.multScalar(time));
        isect_obj = {
          type: 'i',
          point: pt
        };
        isects.push(isect_obj);
        this.road.addPoint(this.pt_to_vec(pt));
      }
      return isects;
    };

    I_Mouse_Build_Road.prototype.vec_to_pt = function(vec) {
      var x, y, z;
      x = vec.x;
      y = vec.y;
      z = vec.z;
      return new BDS.Point(x, y, z);
    };

    I_Mouse_Build_Road.prototype.pt_to_vec = function(pt) {
      var x, y, z;
      x = pt.x;
      y = pt.y;
      z = pt.z;
      return new THREE.Vector3(x, y, z);
    };

    I_Mouse_Build_Road.prototype._intersectPolygons = function(perm_poly, new_poly, road_in_embedding) {
      var data, edge, edge_index, halfedge, i, intersection, isect_datas, isect_obj, j, k, len1, pt, ref;
      isect_datas = perm_poly.report_intersections_with_polyline(new_poly);
      for (j = 0, len1 = isect_datas.length; j < len1; j++) {
        data = isect_datas[j];
        pt = data.point;
        edge_index = data.index;
        halfedge = road_in_embedding.getHalfedge();
        for (i = k = 0, ref = edge_index; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          halfedge = halfedge.next;
        }
        edge = halfedge.edge;
        intersection = new TSAG.E_Intersection(pt);
        isect_obj = {
          isect: intersection,
          type: 's',
          road_edge: edge,
          point: intersection.getPoint()
        };
        this.isects_last_segment.push(isect_obj);
        this.network.addVisual(intersection.getVisual());
      }

      /*
       * Add intersections every time the mouse cursor intersects an older road.
      road_model = @network.query_road(event.x, event.y)
      if road_model != null
          @network.newIntersection(road_model.getPosition())
       */
    };

    I_Mouse_Build_Road.prototype._getIsectOrRoadAtPt = function(pt) {
      var elem, elems, j, k, len1, len2;
      elems = this.network.query_elements_pt(pt.x, pt.y);
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Intersection) {
          return elem;
        }
      }
      for (k = 0, len2 = elems.length; k < len2; k++) {
        elem = elems[k];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    I_Mouse_Build_Road.prototype._getRoadAtPt = function(pt) {
      var elem, elems, j, len1;
      elems = this.network.query_elements_pt(pt.x, pt.y);
      for (j = 0, len1 = elems.length; j < len1; j++) {
        elem = elems[j];
        if (elem instanceof TSAG.E_Road) {
          return elem;
        }
      }
      return null;
    };

    return I_Mouse_Build_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Highlight = (function() {
    function I_Mouse_Highlight(e_scene, camera) {
      this.e_scene = e_scene;
      this.camera = camera;
      this.network = this.e_scene.getNetwork();
      this.previous_elements = [];
    }

    I_Mouse_Highlight.prototype.isIdle = function() {
      return true;
    };

    I_Mouse_Highlight.prototype.finish = function() {
      var prev_elem, results;
      results = [];
      while (this.previous_elements.length > 0) {
        prev_elem = this.previous_elements.pop();
        results.push(prev_elem.revertFillColor());
      }
      return results;
    };

    I_Mouse_Highlight.prototype.mouse_down = function(event) {
      if (this.previous_elements.length > 0) {

        /*
        @network.removeVisual(@previous_element.getVisual())
        @network.removeCollisionPolygon(@previous_element.getCollisionPolygon())
        #@network.removeTopology
         */
      }
    };

    I_Mouse_Highlight.prototype.mouse_up = function(event) {};

    I_Mouse_Highlight.prototype.mouse_move = function(event) {
      var elem, elems, i, len, results, road;
      this.finish();
      elems = this.network.query_elements_pt(event.x, event.y);
      results = [];
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        if (elem instanceof TSAG.E_Road) {
          road = elem;
          road.setFillColor(TSAG.style.highlight);
          results.push(this.previous_elements.push(road));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return I_Mouse_Highlight;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.I_Mouse_Interface = (function() {
    function I_Mouse_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Mouse_Interface.prototype.mouse_down = function(event) {};

    I_Mouse_Interface.prototype.mouse_up = function(event) {};

    I_Mouse_Interface.prototype.mouse_move = function(event) {};

    I_Mouse_Interface.prototype.isIdle = function() {};

    I_Mouse_Interface.prototype.finish = function() {};

    return I_Mouse_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Mouse_Main = (function(superClass) {
    extend(I_Mouse_Main, superClass);

    function I_Mouse_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Mouse_Main.__super__.constructor.call(this);
      this.create_cursor();
      this.road_build_controller = new TSAG.I_Mouse_Build_Road(this.scene, this.camera);
      this.highlight_controller = new TSAG.I_Mouse_Highlight(this.scene, this.camera);
      this._current_mouse_input_controller = this.highlight_controller;
      this.state = "idle";
      this._min_dist = 10;
    }

    I_Mouse_Main.prototype.create_cursor = function() {
      var h, mesh, mesh_factory, params, scale, w;
      mesh_factory = new TSAG.Unit_Meshes();
      params = {
        color: TSAG.style.cursor_circle_color
      };
      mesh = mesh_factory.newCircle(params);
      scale = TSAG.style.cursor_circle_radius;
      mesh.position.z = TSAG.style.cursor_circle_z;
      w = scale;
      h = scale;
      scale = mesh.scale;
      scale.x = w;
      scale.y = h;
      this.scene.addOverlayVisual(mesh);
      return this.pointer = mesh;
    };

    I_Mouse_Main.prototype.mouse_down = function(event) {
      if (this._current_mouse_input_controller !== this.road_build_controller && this._current_mouse_input_controller.isIdle()) {
        this.switchController(this.road_build_controller);
      }
      return this._current_mouse_input_controller.mouse_down(event);
    };

    I_Mouse_Main.prototype.mouse_up = function(event) {
      return this._current_mouse_input_controller.mouse_up(event);
    };

    I_Mouse_Main.prototype.mouse_move = function(event) {
      var pos;
      if (this._current_mouse_input_controller !== this.highlight_controller && this._current_mouse_input_controller.isIdle()) {
        this.switchController(this.highlight_controller);
      }
      pos = this.pointer.position;
      pos.x = event.x;
      pos.y = event.y;
      return this._current_mouse_input_controller.mouse_move(event);
    };

    I_Mouse_Main.prototype.switchController = function(controller) {
      this._current_mouse_input_controller.finish();
      return this._current_mouse_input_controller = controller;
    };

    return I_Mouse_Main;

  })(BDS.Interface_Controller_All);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Building Rotation Time Controller.

Written by Bryce Summmers on 1 - 31 - 2017.

 - A Test time controller that takes every building in the scene and rotates it by a steady rate.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Generate_Cars = (function(superClass) {
    extend(I_Time_Generate_Cars, superClass);

    function I_Time_Generate_Cars(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Generate_Cars.__super__.constructor.call(this);
      this.time_count = 0.0;
      this.time_step = 2000.0;
    }

    I_Time_Generate_Cars.prototype.time = function(dt) {
      var car, i, i_vert, incoming_halfedge, intersection, j, k, l, lane, lanes, len, len1, len2, len3, m, n, network, outgoing_halfedge, outputs, ref, road, roads, src_vert, times, x, y;
      this.time_count += dt;
      this.gen_cars = false;
      if (this.time_count > this.time_step) {
        this.time_count = (this.time_count % this.time_step) - this.time_step;
        this.gen_cars = true;
      }
      network = this.scene.getNetwork();
      roads = network.getRoads();
      for (j = 0, len = roads.length; j < len; j++) {
        road = roads[j];
        lanes = road.getLanes();
        for (k = 0, len1 = lanes.length; k < len1; k++) {
          lane = lanes[k];
          if (this.gen_cars && lane.deadStart()) {
            x = TSAG.style.road_offset_amount;
            y = TSAG.style.road_offset_amount;
            car = new TSAG.E_Car(new THREE.Vector3(x, y, 1));
            network.addVisual(car.getVisual());
            lane.addCar(car);
          }
          if (lane.isEmpty()) {
            continue;
          }
          outputs = lane.moveCars();
          if (outputs.length === 0) {
            continue;
          }
          if (lane.deadEnd()) {
            for (l = 0, len2 = outputs.length; l < len2; l++) {
              car = outputs[l];
              network.removeVisual(car.getVisual());
            }
          }
          i_vert = lane.getEndVert();
          src_vert = lane.getStartVert();
          intersection = i_vert.data.element;
          incoming_halfedge = intersection.getIncomingHalfedgeFrom(src_vert);
          times = Math.floor(Math.random() * 2) + 1;
          for (i = m = 0, ref = times; m < ref; i = m += 1) {
            incoming_halfedge = incoming_halfedge.twin.prev;
          }
          outgoing_halfedge = incoming_halfedge.twin;
          road = outgoing_halfedge.edge.data.element;
          for (n = 0, len3 = outputs.length; n < len3; n++) {
            car = outputs[n];
            road.addCar(car, i_vert);
            car.resetLaneInfo();
          }
        }
      }
    };

    return I_Time_Generate_Cars;

  })(BDS.Interface_Controller_Time);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Time Input Controller.

Written by Bryce Summmers on 1 - 31 - 2017.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Main = (function(superClass) {
    extend(I_Time_Main, superClass);

    function I_Time_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Main.__super__.constructor.call(this);
      this.add_time_input_controller(new TSAG.I_Time_Generate_Cars(this.scene, this.camera));
    }

    return I_Time_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Building Rotation Time Controller.

Written by Bryce Summmers on 1 - 31 - 2017.

 - A Test time controller that takes every building in the scene and rotates it by a steady rate.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.I_Time_Rotate_Buildings = (function(superClass) {
    extend(I_Time_Rotate_Buildings, superClass);

    function I_Time_Rotate_Buildings(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Rotate_Buildings.__super__.constructor.call(this);
    }

    I_Time_Rotate_Buildings.prototype.time = function(dt) {
      var buildings, element, i, len, results;
      buildings = this.scene.getBuildings();
      results = [];
      for (i = 0, len = buildings.length; i < len; i++) {
        element = buildings[i];
        results.push(element.rotateBuilding(.01));
      }
      return results;
    };

    return I_Time_Rotate_Buildings;

  })(BDS.Interface_Controller_All);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      var material;
      this.outline_geometry = outline_geometry;
      material = TSAG.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, material);
      this.line_material = TSAG.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new TSAG.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (!(params.color instanceof THREE.Color)) {
        debugger;
      }
      mesh.material.color = params.color;
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new TSAG.Mesh_Unit_Square();
      this._circle = new TSAG.Mesh_Unit_Circle();
      this._triangle = new TSAG.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * GUI Set.
 *
 * This class may someday use AABB's to optimize clicks and handling of GUI button elements.
 *
 */

(function() {


}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_AABVH = (function() {
    function S_AABVH(obj, xyz) {
      var i, j, left_partition, ref, ref1, right_partition, triangle_list;
      this._leafs = [];
      this._leaf_node = false;
      if (obj instanceof THREE.Object3D) {
        triangle_list = this._extract_triangle_list(obj);
      } else {
        triangle_list = obj;
      }
      this._ensure_bounding_boxes(triangle_list);
      this._AABB = this._compute_AABB(triangle_list);
      if (triangle_list.length < 100) {
        this._leaf_node = true;
        for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangle_list[i]);
        }
        return;
      }
      if (xyz.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      triangle_list = this._sort_triangle_list(triangle_list, xyz);
      ref1 = this._partition_by_SA(triangle_list), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new TSAG.S_AABVH(left_partition, xyz);
      this._right = new TSAG.S_AABVH(right_partition, xyz);
    }

    S_AABVH.prototype.query_point = function(x, y) {
      var ray;
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    S_AABVH.prototype.query_ray = function(ray) {
      var a, b, c, i, intersection, j, output, ref, triangle;
      if (ray.intersectsBox(this._AABB) === null) {
        return null;
      }
      if (this._leaf_node) {
        for (i = j = 0, ref = this._leafs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangle = this._leafs[i];
          a = triangle.a;
          b = triangle.b;
          c = triangle.c;
          intersection = ray.intersectTriangle(a, b, c, false);
          if (intersection !== null) {
            return triangle;
          }
        }
      } else {
        output = this._left.query_ray(ray);
        if (output !== null) {
          return output;
        }
        output = this._right.query_ray(ray);
        if (output !== null) {
          return output;
        }
      }
      return null;
    };

    S_AABVH.prototype.toVisual = function(material) {
      var geom, geometries, j, len1, line, output;
      geometries = [];
      this.get_AABB_geometries(geometries);
      output = new THREE.Object3D();
      for (j = 0, len1 = geometries.length; j < len1; j++) {
        geom = geometries[j];
        line = new THREE.Line(geom, material);
        output.add(line);
      }
      return output;
    };

    S_AABVH.prototype.get_AABB_geometries = function(output) {
      var geometry, max, max_x, max_y, min, min_x, min_y;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(min_x, min_y, 0), new THREE.Vector3(max_x, min_y, 0), new THREE.Vector3(max_x, max_y, 0), new THREE.Vector3(min_x, max_y, 0), new THREE.Vector3(min_x, min_y, 0));
      output.push(geometry);
      if (!this._leaf_node) {
        this._left.get_AABB_geometries(output);
        this._right.get_AABB_geometries(output);
      }
    };


    /*
     - Private Construction Methods. -----------------------
     */

    S_AABVH.prototype._extract_triangle_list = function(obj) {
      var a, b, c, face, faces, geometry, j, k, len1, len2, localToWorld, mesh, mesh_list, triangle, triangle_list, vertices;
      mesh_list = this._extract_mesh_list(obj);
      triangle_list = [];
      for (j = 0, len1 = mesh_list.length; j < len1; j++) {
        mesh = mesh_list[j];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (k = 0, len2 = faces.length; k < len2; k++) {
          face = faces[k];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          triangle = new THREE.Triangle(a, b, c);
          triangle.mesh = mesh;
          triangle_list.push(triangle);
        }
      }
      return triangle_list;
    };

    S_AABVH.prototype._extract_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    S_AABVH.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    S_AABVH.prototype._nextXYZ = function(xyz) {
      if (xyz.dim === 2) {
        switch (xyz.val) {
          case 'x':
            return 'y';
          case 'y':
            return 'x';
          case 'z':
            console.log("xyz is malformed.");
        }
        debugger;
        console.log("xyz is malformed.");
      } else if (xyz.dim === 3) {
        switch (xyz) {
          case 'x':
            return 'y';
          case 'y':
            return 'z';
          case 'z':
            return 'x';
        }
      }
      debugger;
      return console.log("Case not handled.");
    };

    S_AABVH.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    S_AABVH.prototype._computeCentroid = function(triangle) {
      var centroid;
      centroid = new THREE.Vector3(0, 0, 0);
      centroid.add(triangle.a);
      centroid.add(triangle.b);
      centroid.add(triangle.c);
      centroid.divideScalar(3);
      return centroid;
    };

    S_AABVH.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    S_AABVH.prototype._ensure_bounding_boxes = function(triangle_list) {
      var i, j, len, ref, results, triangle;
      len = triangle_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        if (!triangle) {
          debugger;
        }
        if (!triangle.boundingBox) {
          results.push(this._computeBoundingBox(triangle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    S_AABVH.prototype._computeBoundingBox = function(triangle) {
      var AABB;
      AABB = new THREE.Box3();
      AABB.expandByPoint(triangle.a);
      AABB.expandByPoint(triangle.b);
      AABB.expandByPoint(triangle.c);
      return triangle.boundingBox = AABB;
    };

    S_AABVH.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new THREE.Box3();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.boundingBox;
        output.union(AABB);
      }
      return output;
    };

    S_AABVH.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    return S_AABVH;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len = vecs.length; j < len; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
      this._cumulative_lengths = [];
      this._unit_tangents = [];
      this._total_length = 0;
    }

    S_Curve.prototype.addPoint = function(p) {
      this._spline.addPoint(this.vec_to_point(p));
      this._total_length += this._spline.getLastSegmentDistance();
      this._cumulative_lengths.push(this._total_length);
      if (this.numPoints() > 1) {
        this._unit_tangents.push(this._spline.getLastSegmentDirection());
      }
    };

    S_Curve.prototype.numPoints = function() {
      return this._spline.size();
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this.point_to_vec(this._spline.getPoint(i));
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.point_to_vec(this._spline.getLastPoint());
    };

    S_Curve.prototype.removeLastPoint = function() {
      this._total_length -= this._spline.getLastSegmentDistance();
      this._cumulative_lengths.pop();
      this._unit_tangents.pop();
      return this._spline.removeLastPoint();
    };

    S_Curve.prototype.position = function(t) {
      var dir, distance, distance_to_go, i1, i2, p1, p2, start_distance;
      i1 = this._get_segment_start_index(t);
      if (i1 >= this.numPoints() - 1) {
        return this.getLastPoint();
      }
      i2 = i1 + 1;
      distance = t * this._total_length;
      start_distance = this._cumulative_lengths[i1];
      distance_to_go = distance - start_distance;
      p1 = this._spline.getPoint(i1);
      p2 = this._spline.getPoint(i2);
      dir = p1.directionTo(p2);
      return this.point_to_vec(p1.add(dir.multScalar(distance_to_go)));
    };

    S_Curve.prototype.tangent = function(t) {
      var index;
      index = this._get_segment_start_index(t);
      if (index >= this._unit_tangents.length) {
        index--;
      }
      return this.point_to_vec(this._unit_tangents[index]);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype._get_segment_start_index = function(t) {
      var distance;
      distance = t * this._total_length;
      return BDS.Arrays.binarySearch(this._cumulative_lengths, distance);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var index, j, len, ref, vec;
      this._discretization = [];
      len = this.numPoints();
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        vec = this.getPointAtIndex(index);
        this._discretization.push(vec);
      }
      return this._discretization;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var distance, j, len, len1, out, ref, time;
      out = [];
      len = 0;
      ref = this._cumulative_lengths;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        distance = ref[j];
        time = distance / this._total_length;
        times_output.push(time);
        out.push(this.offset(time, amount));
      }
      return out;
    };


    /*
    updateDiscretization: (max_length) ->
        output = []
        p0 = @position(0)
        output.push(p0)
    
        S = [] # Stack.
        S.push(1.0)
        
        low   = 0
        p_low = @position(low)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval
         * every time an interval is less than the max_length, subdivision is terminated.
    
         * Left to right subdivision loop. Performs a binary search across all intervals.
        while S.length != 0
        
            high   = S.pop()
            p_high = @position(high)
        
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high   = (low + high)/2.0
                p_high = @position(high)
        
            output.push(p_high)
            low   = high
            p_low = p_high
            continue
    
        @_discretization = output
    
     * max_length:float, maximum length out output segment.
     * amount: the distance the offset curve is away from the main curve. positive or negative is fine.
     * time_output (optional) will be populated with the times for the output points.
     * ASSUMPTION: this function assumes that it is sampling from continuously defined offsets.
    getOffsets: (max_length, amount, times_output) ->
    
        o0 = @offset(0, amount)
        output = []
        output.push(o0)
        times_output.push(0) if times_output
    
        S = []; # Stack.
        S.push(1.0)
        low = 0
        p_low = @offset(low, amount)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval.
         * every time an interval is terminated after subdivision is sufficient.
    
         * Left to right subdivision loop.
        while S.length != 0
        
            high   = S.pop()
            p_high = @offset(high, amount)
    
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
            
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high = (low + high)/2.0
                p_high = @offset(high, amount)
            
    
            output.push(p_high)
            times_output.push(high) if times_output
            low = high
            p_low = p_high
            continue
        
        return output
     */

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len1, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len1 = vecs.length; j < len1; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    S_Curve.prototype.vec_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y);
    };

    S_Curve.prototype.point_to_vec = function(pt) {
      return new THREE.Vector3(pt.x, pt.y);
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.S_Vertex = (function() {
    function S_Vertex() {
      this._edges = [];
      this._element = null;
    }

    S_Vertex.prototype.addEdge = function(edge) {
      return this._edges.push(edge);
    };

    S_Vertex.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Vertex.prototype.getElement = function() {
      return this._element;
    };

    return S_Vertex;

  })();

  TSAG.S_Edge = (function() {
    function S_Edge() {
      this._v0 = null;
      this._v1 = null;
      this.element = null;
    }

    S_Edge.prototype.getStartVert = function() {
      return this._v0;
    };

    S_Edge.prototype.getEndVert = function() {
      return this._v1;
    };

    S_Edge.prototype.setStartVert = function(v0) {
      return this._v0 = v0;
    };

    S_Edge.prototype.setEndVert = function(v1) {
      return this._v1 = v1;
    };

    S_Edge.prototype.setVerts = function(v0, v1) {
      this._v0 = v0;
      return this._v1 = v1;
    };

    S_Edge.prototype.setElement = function(element) {
      return this._element = element;
    };

    S_Edge.prototype.getElement = function() {
      return this._element;
    };

    return S_Edge;

  })();

  TSAG.S_Network_Topology = (function() {
    function S_Network_Topology() {
      this._bvh_needs_update = true;
      this._bvh = null;
      this._vertices = [];
      this._edges = [];
    }

    S_Network_Topology.prototype.newVertex = function() {
      var vert;
      vert = new TSAG.S_Vertex();
      this._vertices.push(vert);
      return vert;
    };

    S_Network_Topology.prototype.newEdge = function() {
      var edge;
      edge = new TSAG.S_Edge();
      this._edges.push(edge);
      return edge;
    };

    return S_Network_Topology;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  TSAG.init_style = function() {
    TSAG.style = {
      radius_speed1: 50,
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_car_fill: new THREE.Color(0x00aaaa),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0,
      dz_cars: .02,
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000)
    };
    return TSAG.style.unit_meshes = new TSAG.Unit_Meshes();
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers on 12 - 16 - 2016.
 */


/*
 * Testing Axis Aligned Bounding Box.
 */

(function() {
  TSAG.Testing = (function() {
    function Testing() {}

    Testing.prototype.test_AABB = function() {
      var AABB, direction, geometry, i, inter, mesh, origin, ray, ref, scene, x, y;
      scene = new THREE.Scene();
      geometry = new THREE.Geometry();
      y = 0;
      for (x = i = 0; i <= 10; x = ++i) {
        mesh = this.test_mesh(new THREE.Vector3(x * 3 + 0, y * 3 + 1, 0), new THREE.Vector3(x * 3 + -1, y * 3 - 1, 0), new THREE.Vector3(x * 3 + 1, y * 3 - 1, 0));
        scene.add(mesh);
      }
      AABB = new TSAG.AABB(scene, {
        val: 'x',
        dim: 2
      });
      origin = new THREE.Vector3(0, 0, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      ref = AABB.collision_query(ray), mesh = ref[0], inter = ref[1];
      console.log(mesh);
      return console.log(inter);
    };

    Testing.prototype.test_mesh = function(a, b, c) {
      var geometry, material, mesh;
      geometry = new THREE.Geometry();
      geometry.vertices.push(a, b, c);
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      material = new THREE.MeshBasicMaterial({
        color: 0xffff00
      });
      return mesh = new THREE.Mesh(geometry, material);
    };

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Scribble.JS Halfedge Graph data classes.
    Data Classes that associated Sim Urban relevant information with Halfedge graph Topology members.

    Written by Bryce Summers on 3 - 7 - 2017.
 */

(function() {
  TSAG.Graph_Data = (function() {
    function Graph_Data(graph) {
      this.graph = graph;
    }

    Graph_Data.prototype.clearFaceMarks = function() {
      var iter, results;
      iter = this.graph.facesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearVertexMarks = function() {
      var iter, results;
      iter = this.graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearEdgeMarks = function() {
      var iter, results;
      iter = this.graph.edgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearHalfedgeMarks = function() {
      var iter, results;
      iter = this.graph.halfedgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearMarks = function() {
      this.clearFaceMarks();
      this.clearVertexMarks();
      this.clearEdgeMarks();
      return this.clearHalfedgeMarks();
    };

    return Graph_Data;

  })();

  TSAG.Face_Data = (function() {
    function Face_Data(face) {
      this.face = face;
      this.marked = false;
      this.element = null;
    }

    return Face_Data;

  })();

  TSAG.Vertex_Data = (function() {
    function Vertex_Data(vertex) {
      this.vertex = vertex;
      this.marked = false;
      this.point = null;
      this.element = null;
    }

    return Vertex_Data;

  })();

  TSAG.Edge_Data = (function() {
    function Edge_Data(edge) {
      this.edge = edge;
      this.marked = false;
      this.element = null;
    }

    return Edge_Data;

  })();

  TSAG.Halfedge_Data = (function() {
    function Halfedge_Data(halfedge) {
      this.halfedge = halfedge;
      this.marked = false;
      this.next_extraordinary = null;
      this.element = null;

      /*
      @_curve
      @_time1
      @_time2
       */
    }


    /*
    
    I wonder if these will be useful in Sim Urban???
    
     * Halfedges may represent subsections of curves.
    setAssociatedCurve: (obj) ->
        @_curve = obj
        return
    
    getAssociatedCurve: () ->
        return @_curve
    
     * Associate parameter values with the beginning and end of this halfedge.
    setTimes: (time1, time2) ->
        @_time1 = time1
        @_time2 = time2
    
    getTimes: () ->
        return undefined if @_time1 is undefined
        return [@_time1, @_time2]
     */

    return Halfedge_Data;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Sim Urban Topology Linked Element Generator.

Written by Bryce Summers on 3 - 7 - 2017.

Purpose
 */


/*

Polyline Graph Topology Generator.

Generates Halfedge Topology associated with Polyline Graph Data Objects.

Written by Bryce Summers
Move to its own file on 3 - 7 - 2017.
 */

(function() {
  TSAG.TopologyGenerator = (function() {
    function TopologyGenerator(_graph) {
      this._graph = _graph;
      this.new_faces = [];
      this.new_edges = [];
      this.new_halfedges = [];
      this.new_vertices = [];
    }

    TopologyGenerator.prototype.allocateGraph = function() {
      this._graph = this.newGraph();
      return this._graph;
    };

    TopologyGenerator.prototype.newGraph = function() {
      var output;
      output = new SCRIB.Graph(false);
      output.data = new TSAG.Graph_Data(output);
      return output;
    };

    TopologyGenerator.prototype.newFace = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newFace();
      output.data = new TSAG.Face_Data(output);
      this.new_faces.push(output);
      return output;
    };

    TopologyGenerator.prototype.newEdge = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newEdge();
      output.data = new TSAG.Edge_Data(output);
      this.new_edges.push(output);
      return output;
    };

    TopologyGenerator.prototype.newHalfedge = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newHalfedge();
      output.data = new TSAG.Halfedge_Data(output);
      this.new_halfedges.push(output);
      return output;
    };

    TopologyGenerator.prototype.newVertex = function(graph) {
      var output;
      if (!graph) {
        graph = this._graph;
      }
      output = graph.newVertex();
      output.data = new TSAG.Vertex_Data(output);
      this.new_vertices.push(output);
      return output;
    };

    TopologyGenerator.prototype.flushNewFaces = function() {
      var output;
      output = this.new_faces;
      this.new_faces = [];
      return output;
    };

    TopologyGenerator.prototype.flushNewEdges = function() {
      var output;
      output = this.new_edges;
      this.new_edges = [];
      return output;
    };

    TopologyGenerator.prototype.flushNewHalfedges = function() {
      var output;
      output = this.new_halfedges;
      this.new_halfedges = [];
      return output;
    };

    TopologyGenerator.prototype.flushNewVertices = function() {
      var output;
      output = this.new_vertices;
      this.new_vertices = [];
      return output;
    };

    TopologyGenerator.prototype.line_side_test = function(vert1, vert2, vert3) {
      var pt_c, ray;
      pt_c = vert3.data.point;
      ray = this._ray(vert1, vert2);
      return ray.line_side_test(pt_c);
    };

    TopologyGenerator.prototype.vert_in_angle = function(vert_a, vert_b, vert_c, vert_pt) {
      var angle1, angle2, angle_pt, ray1, ray2, ray_pt;
      ray1 = this._ray(vert_b, vert_c);
      ray2 = this._ray(vert_b, vert_a);
      ray_pt = this._ray(vert_b, vert_pt);
      angle1 = ray1.getAngle();
      angle2 = ray2.getAngle();
      angle_pt = ray_pt.getAngle();
      if (angle2 <= angle1) {
        angle2 += Math.PI * 2;
      }
      if (angle_pt < angle1) {
        angle_pt += Math.PI * 2;
      }
      return angle1 <= angle_pt && angle_pt <= angle2;
    };

    TopologyGenerator.prototype._ray = function(v1, v2) {
      var a, b, dir, ray;
      a = v1.data.point;
      b = v2.data.point;
      dir = b.sub(a);
      ray = new BDS.Ray(a, dir, 1);
      return ray;
    };

    return TopologyGenerator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Math = {};

  TSAG.Math.distance = function(x1, y1, x2, y2) {
    return Math.sqrt(TSAG.Math.distance_sqr(x1, y1, x2, y2));
  };

  TSAG.Math.distance_sqr = function(x1, y1, x2, y2) {
    var dx, dy;
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.M_Road = (function() {
    function M_Road(t0, t11, road) {
      this.t0 = t0;
      this.t1 = t11;
      this.road = road;
    }

    M_Road.prototype.getPosition = function() {
      return this.road.getPosition((this.t0 + t1) / 2);
    };

    return M_Road;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(.5, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Square;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(TSAG.Mesh_Basic);

}).call(this);

/*
 * Entry Point to my Transportation Simulation Game.
 * Sets up THREE.js on the DOM and sets up input from the browser.
 * Written by Bryce Summers on 11/22/2016
 */

var renderer;
var root_e_scene;
var root_camera;

var input;
var root_AABB;

function init()
{
    // run some Tests.
    new TSAG.Testing();

    // Initialize all of the global material, mesh constructor's, etc.
    TSAG.init_style();

    // Scene Graph.
    root_e_scene = new TSAG.E_Scene(window.innerWidth, window.innerHeight);

    // Camera.
    var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 2;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))


    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Clear to white Background.
    // FIXME: Use a Style Class.
    // FIXME: Move this to a background prropery of the E_Scene.
    renderer.setClearColor( 0xD8C49E );

    init_input();
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( window.devicePixelRatio );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    // Initialize the root of the input specification tree.
    input = new TSAG.I_All_Main(root_e_scene, root_camera);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);

    // The current system time, used to correctly pass time deltas.
    TIMESTAMP = performance.now();

    // Initialize Time input.
    beginTime();

    TIME_ON = true;
}

function beginTime()
{
    TIMESTAMP = performance.now();
    TIME_ON   = true;
    timestep();
}

function timestep()
{
    if(TIME_ON)
    {
        requestAnimationFrame(timestep)
    }
    else
    {
        return;
    }

    time_new = performance.now()
    var dt = time_new - TIMESTAMP
    TIMESTAMP = time_new

    try
    {
        input.time(dt)
    }
    catch(err)
    { // Stop time on error.
        TIME_ON = false
        throw err
    }

}

// Events.
function onWindowResize( event )
{
    renderer.setSize( window.innerWidth, window.innerHeight );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
}

function onMouseMove( event )
{
    input.mouse_move(event);
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    if(isRightMB)
        return

    input.mouse_down(e);
}

function onMouseUp( event )
{
    input.mouse_up(event);
}

function animate()
{
    requestAnimationFrame( animate );
    render();
}

function render()
{
    renderer.render(root_e_scene.getVisual(), root_camera);
}

init();
animate();