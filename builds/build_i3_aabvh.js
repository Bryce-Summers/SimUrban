/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 20-12-2016
 */
/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
TSAG = {};

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Set = (function() {
    function Set() {}

    Set.prototype.add = function(object) {
      console.log("ERROR: BT2D: intersectRay. This method should be overriden.");
      return false;
    };

    Set.prototype.clear = function() {};

    Set.prototype.remove = function(object) {};

    return Set;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Mouse_Input_Controller = (function() {
    function Mouse_Input_Controller(scene, camera) {
      var h, mesh, mesh_factory, params, scale, w;
      this.scene = scene;
      this.camera = camera;
      mesh_factory = this.scene.getMeshFactory();
      params = {
        color: 0xff0000
      };
      mesh = mesh_factory.newCircle(params);
      scale = 10;
      mesh.position.z = 1;
      w = scale;
      h = scale;
      scale = mesh.scale;
      scale.x = w;
      scale.y = h;
      this.scene.add(mesh);
      this.pointer = mesh;
      this.state = "idle";
      this._mousePrevious = {
        x: 0,
        y: 0
      };
      this._min_dist = 10;
    }

    Mouse_Input_Controller.prototype.mouse_down = function(event, rightButton) {
      var dist, intersection, mesh, pos, results;
      results = this.scene.queryPoint(event.x, event.y);
      console.log(event.x, event.y);
      if (results !== null) {
        mesh = results[0];
        intersection = results[1];
        mesh.material.color.set(0xff0000);
      }
      return;
      if (rightButton) {
        return;
      }
      if (this.state === "idle") {
        this.road = new TSAG.Curve();
        this.road.addPoint(new THREE.Vector3(event.x, event.y, 0));
        this.road.addPoint(new THREE.Vector3(event.x, event.y + 1, 0));
        this.state = "building";
        this._mousePrevious.x = event.x;
        return this._mousePrevious.y = event.y;
      } else {
        dist = TSAG.Math.distance(event.x, event.y, this._mousePrevious.x, this._mousePrevious.y);
        if (dist > this._min_dist) {
          pos = this.road.getLastPoint();
          pos.x = Math.floor(pos.x);
          pos.y = Math.floor(pos.y);
          this.road.addPoint(new THREE.Vector3(event.x + .01, event.y + .01, 0));
          this._mousePrevious.x = event.x;
          return this._mousePrevious.y = event.y;
        } else {
          this.road.removeLastPoint();
          this.state = "idle";
          return this.road_obj = null;
        }
      }

      /*
      if rightButton
          @state = "idle"
           * Preserve the Road object.
          @road_obj = null
       */
    };

    Mouse_Input_Controller.prototype.mouse_up = function(event) {};

    Mouse_Input_Controller.prototype.mouse_move = function(event) {
      var left_line, len, material, max_length, middle_line, middle_material, offset_amount, pos, right_line, screen_h, screen_w;
      pos = this.pointer.position;
      screen_w = window.innerWidth;
      screen_h = window.innerHeight;
      pos.x = event.x;
      pos.y = event.y;
      if (this.road_obj) {
        this.scene.remove(this.road_obj);
      }
      if (this.state === "building") {
        len = this.road.numPoints();
        pos = this.road.getPointAtIndex(len - 1);
        pos.x = event.x + .01;
        pos.y = event.y + .01;
        max_length = 10;
        offset_amount = 10;
        this.road.updateDiscretization(10);
        this.road_obj = new THREE.Object3D();
        material = new THREE.LineBasicMaterial({
          color: 0x000000
        });
        middle_material = new THREE.LineBasicMaterial({
          color: 0x514802
        });
        middle_line = new THREE.Geometry();
        middle_line.vertices = this.road.getDiscretization();
        this.road_obj.add(new THREE.Line(middle_line, middle_material));
        left_line = new THREE.Geometry();
        left_line.vertices = this.road.getOffsets(max_length, offset_amount);
        this.road_obj.add(new THREE.Line(left_line, material));
        right_line = new THREE.Geometry();
        right_line.vertices = this.road.getOffsets(max_length, -offset_amount);
        this.road_obj.add(new THREE.Line(right_line, material));
        return this.scene.add(this.road_obj);
      }
    };

    return Mouse_Input_Controller;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Curve = (function() {
    function Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._discretization = [];
    }

    Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    Curve.prototype.getOffsets = function(max_length, amount) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      var material;
      this.outline_geometry = outline_geometry;
      material = new THREE.MeshBasicMaterial({
        color: 0xaaaaaa,
        side: THREE.DoubleSide
      });
      Mesh_Basic.__super__.constructor.call(this, area_geometry, material);
      this.line_material = new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      });
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new TSAG.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      mesh.material.color = new THREE.Color(params.color);
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new TSAG.Mesh_Unit_Square();
      this._circle = new TSAG.Mesh_Unit_Circle();
      this._triangle = new TSAG.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Random Scene.
    Written by Bryce on 11/22/2016
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Random_Scene = (function(superClass) {
    extend(Random_Scene, superClass);

    function Random_Scene(scene_width, scene_height) {
      var h, i, j, mesh, pos, rotation, scale, w, x, y;
      Random_Scene.__super__.constructor.call(this);
      this._scale = 40;
      this._padding = 30;
      this._Mesh_Factory = new TSAG.Unit_Meshes();
      this._AABB = null;
      for (i = j = 0; j < 1000; i = ++j) {
        mesh = this._newHouse({
          color: 0xaaaaaa
        });
        x = this._padding + Math.random() * (scene_width - this._padding * 2);
        y = this._padding + Math.random() * (scene_height - this._padding * 2);
        w = this._scale;
        h = this._scale;
        pos = mesh.position;
        pos.x = x;
        pos.y = y;
        scale = mesh.scale;
        scale.x = w;
        scale.y = h;
        rotation = mesh.rotation;
        rotation.z = Math.random() * Math.PI * 2;
        this.add(mesh);
      }
      return;
    }

    Random_Scene.prototype._newHouse = function(params) {
      var node, square, triangle;
      square = this._Mesh_Factory.newSquare(params);
      triangle = this._Mesh_Factory.newTriangle(params);
      triangle.position.x = .5;
      triangle.scale.x = .5;
      node = new THREE.Object3D();
      node.add(square);
      node.add(triangle);
      return node;
    };

    Random_Scene.prototype.getMeshFactory = function() {
      return this._Mesh_Factory;
    };

    Random_Scene.prototype.queryPoint = function(x, y) {
      var aabb_line_meshes, direction, j, len, line_material, mesh, origin, ray, results;
      if (this._AABB === null) {
        this._AABB = new TSAG.AABB(this, {
          val: 'x',
          dim: 2
        });
        line_material = new THREE.LineBasicMaterial({
          color: 0x0000ff
        });
        aabb_line_meshes = this._AABB.get_AABB_line_meshes(line_material);
        for (j = 0, len = aabb_line_meshes.length; j < len; j++) {
          mesh = aabb_line_meshes[j];
          this.add(mesh);
        }
      }
      origin = new THREE.Vector3(x, y, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      results = this._AABB.collision_query(ray);
      return results;
    };

    return Random_Scene;

  })(THREE.Scene);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.AABB = (function() {
    function AABB(obj, xyz) {
      var i, j, left_partition, ref, ref1, right_partition, triangle_list;
      this._leafs = [];
      if (obj instanceof THREE.Object3D) {
        triangle_list = this._extract_triangle_list(obj);
      } else {
        triangle_list = obj;
      }
      this._ensure_bounding_boxes(triangle_list);
      this._AABB = this._compute_AABB(triangle_list);
      if (triangle_list.length < 100) {
        for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangle_list[i]);
        }
        return;
      }
      if (xyz.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      triangle_list = this._sort_triangle_list(triangle_list, xyz);
      ref1 = this._partition_by_SA(triangle_list), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new TSAG.AABB(left_partition, xyz);
      this._right = new TSAG.AABB(right_partition, xyz);
    }

    AABB.prototype.collision_query = function(ray) {
      var a, b, c, i, intersection, j, output, ref, triangle;
      if (ray.intersectsBox(this._AABB) === null) {
        return null;
      }
      if (this._leafs.length > 0) {
        for (i = j = 0, ref = this._leafs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangle = this._leafs[i];
          a = triangle.a;
          b = triangle.b;
          c = triangle.c;
          intersection = ray.intersectTriangle(a, b, c, false);
          if (intersection !== null) {
            return [triangle.mesh, intersection];
          }
        }
      } else {
        output = this._left.collision_query(ray);
        if (output !== null) {
          return output;
        }
        output = this._right.collision_query(ray);
        if (output !== null) {
          return output;
        }
      }
      return null;
    };

    AABB.prototype.get_AABB_line_meshes = function(material) {
      var geom, geometries, j, len1, line, output;
      geometries = [];
      this.get_AABB_geometries(geometries);
      output = [];
      for (j = 0, len1 = geometries.length; j < len1; j++) {
        geom = geometries[j];
        line = new THREE.Line(geom, material);
        output.push(line);
      }
      return output;
    };

    AABB.prototype.get_AABB_geometries = function(output) {
      var geometry, max, max_x, max_y, min, min_x, min_y;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(min_x, min_y, 0), new THREE.Vector3(max_x, min_y, 0), new THREE.Vector3(max_x, max_y, 0), new THREE.Vector3(min_x, max_y, 0), new THREE.Vector3(min_x, min_y, 0));
      output.push(geometry);
      if (this._leafs.length === 0) {
        this._left.get_AABB_geometries(output);
        this._right.get_AABB_geometries(output);
      }
    };


    /*
     - Private Construction Methods. -----------------------
     */

    AABB.prototype._extract_triangle_list = function(obj) {
      var a, b, c, face, faces, geometry, j, k, len1, len2, localToWorld, mesh, mesh_list, triangle, triangle_list, vertices;
      mesh_list = this._extract_mesh_list(obj);
      triangle_list = [];
      for (j = 0, len1 = mesh_list.length; j < len1; j++) {
        mesh = mesh_list[j];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (k = 0, len2 = faces.length; k < len2; k++) {
          face = faces[k];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          triangle = new THREE.Triangle(a, b, c);
          triangle.mesh = mesh;
          triangle_list.push(triangle);
        }
      }
      return triangle_list;
    };

    AABB.prototype._extract_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    AABB.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    AABB.prototype._nextXYZ = function(xyz) {
      if (xyz.dim === 2) {
        switch (xyz.val) {
          case 'x':
            return 'y';
          case 'y':
            return 'x';
          case 'z':
            console.log("xyz is malformed.");
        }
        debugger;
        console.log("xyz is malformed.");
      } else if (xyz.dim === 3) {
        switch (xyz) {
          case 'x':
            return 'y';
          case 'y':
            return 'z';
          case 'z':
            return 'x';
        }
      }
      debugger;
      return console.log("Case not handled.");
    };

    AABB.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    AABB.prototype._computeCentroid = function(triangle) {
      var centroid;
      centroid = new THREE.Vector3(0, 0, 0);
      centroid.add(triangle.a);
      centroid.add(triangle.b);
      centroid.add(triangle.c);
      centroid.divideScalar(3);
      return centroid;
    };

    AABB.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    AABB.prototype._ensure_bounding_boxes = function(triangle_list) {
      var i, j, len, ref, results, triangle;
      len = triangle_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        if (!triangle) {
          debugger;
        }
        if (!triangle.boundingBox) {
          results.push(this._computeBoundingBox(triangle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    AABB.prototype._computeBoundingBox = function(triangle) {
      var AABB;
      AABB = new THREE.Box3();
      AABB.expandByPoint(triangle.a);
      AABB.expandByPoint(triangle.b);
      AABB.expandByPoint(triangle.c);
      return triangle.boundingBox = AABB;
    };

    AABB.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new THREE.Box3();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.boundingBox;
        output.union(AABB);
      }
      return output;
    };

    AABB.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    return AABB;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers on 12 - 16 - 2016.
 */


/*
 * Testing Axis Aligned Bounding Box.
 */

(function() {
  TSAG.Testing = (function() {
    function Testing() {}

    Testing.prototype.test_AABB = function() {
      var AABB, direction, geometry, i, inter, mesh, origin, ray, ref, scene, x, y;
      scene = new THREE.Scene();
      geometry = new THREE.Geometry();
      y = 0;
      for (x = i = 0; i <= 10; x = ++i) {
        mesh = this.test_mesh(new THREE.Vector3(x * 3 + 0, y * 3 + 1, 0), new THREE.Vector3(x * 3 + -1, y * 3 - 1, 0), new THREE.Vector3(x * 3 + 1, y * 3 - 1, 0));
        scene.add(mesh);
      }
      AABB = new TSAG.AABB(scene, {
        val: 'x',
        dim: 2
      });
      origin = new THREE.Vector3(0, 0, -10);
      direction = new THREE.Vector3(0, 0, 1);
      ray = new THREE.Ray(origin, direction);
      ref = AABB.collision_query(ray), mesh = ref[0], inter = ref[1];
      console.log(mesh);
      return console.log(inter);
    };

    Testing.prototype.test_mesh = function(a, b, c) {
      var geometry, material, mesh;
      geometry = new THREE.Geometry();
      geometry.vertices.push(a, b, c);
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      material = new THREE.MeshBasicMaterial({
        color: 0xffff00
      });
      return mesh = new THREE.Mesh(geometry, material);
    };

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  TSAG.Math = {};

  TSAG.Math.distance = function(x1, y1, x2, y2) {
    return Math.sqrt(TSAG.Math.distance_sqr(x1, y1, x2, y2));
  };

  TSAG.Math.distance_sqr = function(x1, y1, x2, y2) {
    var dx, dy;
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(.5, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Square;

  })(TSAG.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TSAG.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(TSAG.Mesh_Basic);

}).call(this);

/*
 * Entry Point to my Transportation Simulation Game.
 * Sets up THREE.js on the DOM and sets up input from the browser.
 * Written by Bryce Summers on 11/22/2016
 */

var renderer;
var root_scene;
var root_camera;
var mouse_input;
var root_AABB;

function init()
{
    // run some Tests.
    new TSAG.Testing();

    // Scene Graph.
    root_scene = new TSAG.Random_Scene(window.innerWidth, window.innerHeight);

    // Camera.
    var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 2;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))


    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Clear to white Background.
    // FIXME: Use a Style Class.
    renderer.setClearColor( 0xD8C49E );

    init_input();
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( window.devicePixelRatio );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    mouse_input = new TSAG.Mouse_Input_Controller(root_scene, root_camera);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);
}


// Events.
function onWindowResize( event )
{
    renderer.setSize( window.innerWidth, window.innerHeight );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
    
    
}

function onMouseMove( event )
{
    mouse_input.mouse_move(event);
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    mouse_input.mouse_down(e, isRightMB);
}

function onMouseUp( event )
{
    mouse_input.mouse_up(event);
}

function animate() {

    requestAnimationFrame( animate );
    render();

}

function render() {

    renderer.render(root_scene, root_camera);
}

init();
animate();